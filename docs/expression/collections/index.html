<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.3.dev5+gbec6307" />
<title>expression.collections API documentation</title>
<meta name="description" content="Collection abstractions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>expression.collections</code></h1>
</header>
<section id="section-intro">
<p>Collection abstractions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Collection abstractions.
&#34;&#34;&#34;
from . import asyncseq, frozenlist, map, seq
from .frozenlist import FrozenList
from .map import Map
from .seq import Seq

__all__ = [
    &#34;asyncseq&#34;,
    &#34;FrozenList&#34;,
    &#34;frozenlist&#34;,
    &#34;Map&#34;,
    &#34;map&#34;,
    &#34;Seq&#34;,
    &#34;seq&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="expression.collections.asyncseq" href="asyncseq.html">expression.collections.asyncseq</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="expression.collections.frozenlist" href="frozenlist.html">expression.collections.frozenlist</a></code></dt>
<dd>
<div class="desc"><p>A frozen immutable list module …</p></div>
</dd>
<dt><code class="name"><a title="expression.collections.map" href="map.html">expression.collections.map</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="expression.collections.maptree" href="maptree.html">expression.collections.maptree</a></code></dt>
<dd>
<div class="desc"><p>The maptree module …</p></div>
</dd>
<dt><code class="name"><a title="expression.collections.seq" href="seq.html">expression.collections.seq</a></code></dt>
<dd>
<div class="desc"><p>Sequence module …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="expression.collections.FrozenList"><code class="flex name class">
<span>class <span class="ident">FrozenList</span></span>
<span>(</span><span>value: Optional[Iterable[TSource]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Immutable list type.</p>
<p>Is faster than <code>List</code> for prepending, but slower for
appending.</p>
<p>Count: 200K</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>FrozenList</th>
<th>List</th>
</tr>
</thead>
<tbody>
<tr>
<td>Append</td>
<td>3.29 s</td>
<td>0.02 s</td>
</tr>
<tr>
<td>Prepend</td>
<td>0.05 s</td>
<td>7.02 s</td>
</tr>
</tbody>
</table>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; xs = Cons(5, Cons(4, Cons(3, Cons(2, Cons(1, Nil)))))
&gt;&gt;&gt; ys = empty.cons(1).cons(2).cons(3).cons(4).cons(5)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrozenList(Generic[TSource]):
    &#34;&#34;&#34;Immutable list type.

    Is faster than `List` for prepending, but slower for
    appending.

    Count: 200K

    | Operation | FrozenList | List   |
    |-----------|------------|--------|
    | Append    | 3.29 s     | 0.02 s |
    | Prepend   | 0.05 s     | 7.02 s |

    Example:
        &gt;&gt;&gt; xs = Cons(5, Cons(4, Cons(3, Cons(2, Cons(1, Nil)))))
        &gt;&gt;&gt; ys = empty.cons(1).cons(2).cons(3).cons(4).cons(5)
    &#34;&#34;&#34;

    def __init__(self, value: Optional[Iterable[TSource]] = None) -&gt; None:
        # Use composition instead of inheritance since generic tuples
        # are not suppored by mypy.
        self.value: Tuple[TSource, ...] = tuple(value) if value else tuple()

    def match(self, pattern: Any) -&gt; Any:
        case: Case[TSource] = Case(self)
        return case(pattern) if pattern else case

    @overload
    def pipe(self, __fn1: Callable[[FrozenList[TSource]], TResult]) -&gt; TResult:
        ...

    @overload
    def pipe(self, __fn1: Callable[[FrozenList[TSource]], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(
        self, __fn1: Callable[[FrozenList[TSource]], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]
    ) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[FrozenList[TSource]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[FrozenList[TSource]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
    ) -&gt; T5:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[FrozenList[TSource]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
        __fn6: Callable[[T5], T6],
    ) -&gt; T6:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe list through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    def append(self, other: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Append frozen list to end of the frozen list.&#34;&#34;&#34;

        return FrozenList(self.value + other.value)

    def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; FrozenList[TResult]:
        &#34;&#34;&#34;Choose items from the list.

        Applies the given function to each element of the list. Returns
        the list comprised of the results x for each element where the
        function returns `Some(x)`.

        Args:
            chooser: The function to generate options from the elements.

        Returns:
            The list comprising the values selected from the chooser
            function.
        &#34;&#34;&#34;

        def mapper(x: TSource) -&gt; FrozenList[TResult]:
            return FrozenList(chooser(x).to_seq())

        return self.collect(mapper)

    def collect(self, mapping: Callable[[TSource], FrozenList[TResult]]) -&gt; FrozenList[TResult]:
        mapped = builtins.map(mapping, self.value)
        xs = (y for x in mapped for y in x)
        return FrozenList(xs)

    def cons(self, element: TSource) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Add element to front of list.&#34;&#34;&#34;

        return FrozenList((element,) + self.value)  # NOTE: Faster than (element, *self)

    @staticmethod
    def empty() -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Returns empty list.&#34;&#34;&#34;

        return FrozenList()

    def filter(self, predicate: Callable[[TSource], bool]) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Filter list.

        Returns a new collection containing only the elements of the
        collection for which the given predicate returns `True`.

        Args:
            predicate: The function to test the input elements.

        Returns:
            A list containing only the elements that satisfy the
            predicate.
        &#34;&#34;&#34;
        return FrozenList(builtins.filter(predicate, self.value))

    def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
        &#34;&#34;&#34;Applies a function to each element of the collection,
        threading an accumulator argument through the computation. Take
        the second argument, and apply the function to it and the first
        element of the list. Then feed this result into the function
        along with the second element and so on. Return the final
        result. If the input function is f and the elements are i0...iN
        then computes f (... (f s i0) i1 ...) iN.

        Args:
            folder: The function to update the state given the input
                elements.

            state: The initial state.

        Returns:
            Partially applied fold function that takes the source list
            and returns the final state value.
        &#34;&#34;&#34;
        return functools.reduce(folder, self, state)

    def forall(self, predicate: Callable[[TSource], bool]) -&gt; bool:
        &#34;&#34;&#34;Tests if all elements of the collection satisfy the given
        predicate.

        Args:
            predicate: The function to test the input elements.

        Returns:
            True if all of the elements satisfy the predicate.
        &#34;&#34;&#34;
        return all(predicate(x) for x in self)

    def head(self) -&gt; TSource:
        &#34;&#34;&#34;Returns the first element of the list.

        Args:
            source: The input list.

        Returns:
            The first element of the list.

        Raises:
            ValueError: Thrown when the list is empty.
        &#34;&#34;&#34;

        head, *_ = self
        return head

    def indexed(self, start: int = 0) -&gt; FrozenList[Tuple[int, TSource]]:
        &#34;&#34;&#34;Returns a new list whose elements are the corresponding
        elements of the input list paired with the index (from `start`)
        of each element.

        Args:
            start: Optional index to start from. Defaults to 0.

        Returns:
            The list of indexed elements.
        &#34;&#34;&#34;
        return of_seq(enumerate(self))

    def item(self, index: int) -&gt; TSource:
        &#34;&#34;&#34;Indexes into the list. The first element has index 0.

        Args:
            index: The index to retrieve.

        Returns:
            The value at the given index.
        &#34;&#34;&#34;
        return self[index]

    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;Return `True` if list is empty.&#34;&#34;&#34;

        return not bool(self)

    def map(self, mapping: Callable[[TSource], TResult]) -&gt; FrozenList[TResult]:
        &#34;&#34;&#34;Map list.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection.

        Args:
            mapping: The function to transform elements from the input
                list.

        Returns:
            The list of transformed elements.
        &#34;&#34;&#34;
        return FrozenList((*builtins.map(mapping, self),))

    def mapi(self, mapping: Callable[[int, TSource], TResult]) -&gt; FrozenList[TResult]:
        &#34;&#34;&#34;Map list with index.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection. The integer index passed to the function indicates
        the index (from 0) of element being transformed.

        Args:
            mapping: The function to transform elements and their
                indices.

        Returns:
            The list of transformed elements.
        &#34;&#34;&#34;
        return FrozenList((*itertools.starmap(mapping, enumerate(self)),))

    @staticmethod
    def of(*args: TSource) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Create list from a number of arguments.&#34;&#34;&#34;
        return FrozenList((*args,))

    @staticmethod
    def of_seq(xs: Iterable[TSource]) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Create list from iterable sequence.&#34;&#34;&#34;
        return FrozenList((*xs,))

    @staticmethod
    def of_option(option: Option[TSource]) -&gt; FrozenList[TSource]:
        return of_option(option)

    @overload
    @staticmethod
    def range(stop: int) -&gt; FrozenList[int]:
        ...

    @overload
    @staticmethod
    def range(start: int, stop: int) -&gt; FrozenList[int]:
        ...

    @overload
    @staticmethod
    def range(start: int, stop: int, step: int) -&gt; FrozenList[int]:
        ...

    @staticmethod
    def range(*args: int, **kw: int) -&gt; FrozenList[int]:
        return range(*args, **kw)

    @staticmethod
    def singleton(item: TSource) -&gt; FrozenList[TSource]:
        return singleton(item)

    def skip(self, count: int) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Returns the list after removing the first N elements.

        Args:
            count: The number of elements to skip.

        Returns:
            The list after removing the first N elements.
        &#34;&#34;&#34;
        return FrozenList(self.value[count:])

    def skip_last(self, count: int) -&gt; FrozenList[TSource]:
        return FrozenList(self.value[:-count])

    def tail(self) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Return tail of List.&#34;&#34;&#34;

        _, *tail = self.value
        return FrozenList(tail)

    def take(self, count: int) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Returns the first N elements of the list.

        Args:
            count: The number of items to take.

        Returns:
            The result list.
        &#34;&#34;&#34;
        return FrozenList(self.value[:count])

    def take_last(self, count: int) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Returns a specified number of contiguous elements from the
        end of the list.

        Args:
            count: The number of items to take.

        Returns:
            The result list.
        &#34;&#34;&#34;
        return FrozenList(self.value[-count:])

    def try_head(self) -&gt; Option[TSource]:
        &#34;&#34;&#34;Returns the first element of the list, or None if the list is
        empty.
        &#34;&#34;&#34;
        if self.value:
            value = cast(&#34;TSource&#34;, self.value[0])
            return Some(value)

        return Nothing

    @staticmethod
    def unfold(generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Returns a list that contains the elements generated by the
        given computation. The given initial state argument is passed to
        the element generator.

        Args:
            generator: A function that takes in the current state and
                returns an option tuple of the next element of the list
                and the next state value.
            state: The initial state.

        Returns:
            The result list.
        &#34;&#34;&#34;

        return pipe(state, unfold(generator))

    def zip(self, other: FrozenList[TResult]) -&gt; FrozenList[Tuple[TSource, TResult]]:
        &#34;&#34;&#34;Combines the two lists into a list of pairs. The two lists
        must have equal lengths. .

        Args:
            other: The second input list.

        Returns:
            A single list containing pairs of matching elements from the
            input lists.
        &#34;&#34;&#34;
        return of_seq(builtins.zip(self.value, other.value))

    def __add__(self, other: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return FrozenList(self.value + other.value)

    @overload
    def __getitem__(self, key: slice) -&gt; FrozenList[TSource]:
        ...

    @overload
    def __getitem__(self, key: int) -&gt; TSource:
        ...

    def __getitem__(self, key: Any) -&gt; Any:
        return self.value[key]

    def __iter__(self) -&gt; Iterator[TSource]:
        return iter(self.value)

    def __eq__(self, o: Any) -&gt; bool:
        return self.value == o

    def __len__(self) -&gt; int:
        return len(self.value)

    def __match__(self, pattern: Any) -&gt; Iterable[List[TSource]]:
        if self == pattern:
            return [[val for val in self]]

        try:
            origin: Any = get_origin(pattern)
            if isinstance(self, origin or pattern):
                return [[val for val in self]]
        except TypeError:
            pass

        return []

    def __str__(self) -&gt; str:
        return f&#34;[{&#39;, &#39;.join(self.map(str))}]&#34;

    def __repr__(self) -&gt; str:
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="expression.collections.FrozenList.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns empty list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty() -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Returns empty list.&#34;&#34;&#34;

    return FrozenList()</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>*args: TSource) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Create list from a number of arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of(*args: TSource) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Create list from a number of arguments.&#34;&#34;&#34;
    return FrozenList((*args,))</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.of_option"><code class="name flex">
<span>def <span class="ident">of_option</span></span>(<span>option: Option[TSource]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of_option(option: Option[TSource]) -&gt; FrozenList[TSource]:
    return of_option(option)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.of_seq"><code class="name flex">
<span>def <span class="ident">of_seq</span></span>(<span>xs: Iterable[TSource]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Create list from iterable sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of_seq(xs: Iterable[TSource]) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Create list from iterable sequence.&#34;&#34;&#34;
    return FrozenList((*xs,))</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>*args: int, **kw: int) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def range(*args: int, **kw: int) -&gt; FrozenList[int]:
    return range(*args, **kw)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.singleton"><code class="name flex">
<span>def <span class="ident">singleton</span></span>(<span>item: TSource) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def singleton(item: TSource) -&gt; FrozenList[TSource]:
    return singleton(item)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.unfold"><code class="name flex">
<span>def <span class="ident">unfold</span></span>(<span>generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list that contains the elements generated by the
given computation. The given initial state argument is passed to
the element generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>A function that takes in the current state and
returns an option tuple of the next element of the list
and the next state value.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unfold(generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Returns a list that contains the elements generated by the
    given computation. The given initial state argument is passed to
    the element generator.

    Args:
        generator: A function that takes in the current state and
            returns an option tuple of the next element of the list
            and the next state value.
        state: The initial state.

    Returns:
        The result list.
    &#34;&#34;&#34;

    return pipe(state, unfold(generator))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="expression.collections.FrozenList.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, other: <a title="expression.collections.FrozenList" href="#expression.collections.FrozenList">FrozenList</a>[TSource]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Append frozen list to end of the frozen list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, other: FrozenList[TSource]) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Append frozen list to end of the frozen list.&#34;&#34;&#34;

    return FrozenList(self.value + other.value)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.choose"><code class="name flex">
<span>def <span class="ident">choose</span></span>(<span>self, chooser: Callable[[TSource], Option[TResult]]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]</span>
</code></dt>
<dd>
<div class="desc"><p>Choose items from the list.</p>
<p>Applies the given function to each element of the list. Returns
the list comprised of the results x for each element where the
function returns <code>Some(x)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chooser</code></strong></dt>
<dd>The function to generate options from the elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list comprising the values selected from the chooser
function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; FrozenList[TResult]:
    &#34;&#34;&#34;Choose items from the list.

    Applies the given function to each element of the list. Returns
    the list comprised of the results x for each element where the
    function returns `Some(x)`.

    Args:
        chooser: The function to generate options from the elements.

    Returns:
        The list comprising the values selected from the chooser
        function.
    &#34;&#34;&#34;

    def mapper(x: TSource) -&gt; FrozenList[TResult]:
        return FrozenList(chooser(x).to_seq())

    return self.collect(mapper)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.collect"><code class="name flex">
<span>def <span class="ident">collect</span></span>(<span>self, mapping: Callable[[TSource], <a title="expression.collections.FrozenList" href="#expression.collections.FrozenList">FrozenList</a>[TResult]]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect(self, mapping: Callable[[TSource], FrozenList[TResult]]) -&gt; FrozenList[TResult]:
    mapped = builtins.map(mapping, self.value)
    xs = (y for x in mapped for y in x)
    return FrozenList(xs)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.cons"><code class="name flex">
<span>def <span class="ident">cons</span></span>(<span>self, element: TSource) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Add element to front of list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cons(self, element: TSource) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Add element to front of list.&#34;&#34;&#34;

    return FrozenList((element,) + self.value)  # NOTE: Faster than (element, *self)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, predicate: Callable[[TSource], bool]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Filter list.</p>
<p>Returns a new collection containing only the elements of the
collection for which the given predicate returns <code>True</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>The function to test the input elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list containing only the elements that satisfy the
predicate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, predicate: Callable[[TSource], bool]) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Filter list.

    Returns a new collection containing only the elements of the
    collection for which the given predicate returns `True`.

    Args:
        predicate: The function to test the input elements.

    Returns:
        A list containing only the elements that satisfy the
        predicate.
    &#34;&#34;&#34;
    return FrozenList(builtins.filter(predicate, self.value))</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, folder: Callable[[TState, TSource], TState], state: TState) ‑> ~TState</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a function to each element of the collection,
threading an accumulator argument through the computation. Take
the second argument, and apply the function to it and the first
element of the list. Then feed this result into the function
along with the second element and so on. Return the final
result. If the input function is f and the elements are i0&hellip;iN
then computes f (&hellip; (f s i0) i1 &hellip;) iN.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder</code></strong></dt>
<dd>The function to update the state given the input
elements.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied fold function that takes the source list
and returns the final state value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
    &#34;&#34;&#34;Applies a function to each element of the collection,
    threading an accumulator argument through the computation. Take
    the second argument, and apply the function to it and the first
    element of the list. Then feed this result into the function
    along with the second element and so on. Return the final
    result. If the input function is f and the elements are i0...iN
    then computes f (... (f s i0) i1 ...) iN.

    Args:
        folder: The function to update the state given the input
            elements.

        state: The initial state.

    Returns:
        Partially applied fold function that takes the source list
        and returns the final state value.
    &#34;&#34;&#34;
    return functools.reduce(folder, self, state)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.forall"><code class="name flex">
<span>def <span class="ident">forall</span></span>(<span>self, predicate: Callable[[TSource], bool]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if all elements of the collection satisfy the given
predicate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>The function to test the input elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if all of the elements satisfy the predicate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forall(self, predicate: Callable[[TSource], bool]) -&gt; bool:
    &#34;&#34;&#34;Tests if all elements of the collection satisfy the given
    predicate.

    Args:
        predicate: The function to test the input elements.

    Returns:
        True if all of the elements satisfy the predicate.
    &#34;&#34;&#34;
    return all(predicate(x) for x in self)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self) ‑> ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first element of the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>The input list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The first element of the list.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Thrown when the list is empty.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self) -&gt; TSource:
    &#34;&#34;&#34;Returns the first element of the list.

    Args:
        source: The input list.

    Returns:
        The first element of the list.

    Raises:
        ValueError: Thrown when the list is empty.
    &#34;&#34;&#34;

    head, *_ = self
    return head</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.indexed"><code class="name flex">
<span>def <span class="ident">indexed</span></span>(<span>self, start: int = 0) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[int, ~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new list whose elements are the corresponding
elements of the input list paired with the index (from <code>start</code>)
of each element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>Optional index to start from. Defaults to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list of indexed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indexed(self, start: int = 0) -&gt; FrozenList[Tuple[int, TSource]]:
    &#34;&#34;&#34;Returns a new list whose elements are the corresponding
    elements of the input list paired with the index (from `start`)
    of each element.

    Args:
        start: Optional index to start from. Defaults to 0.

    Returns:
        The list of indexed elements.
    &#34;&#34;&#34;
    return of_seq(enumerate(self))</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if list is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self) -&gt; bool:
    &#34;&#34;&#34;Return `True` if list is empty.&#34;&#34;&#34;

    return not bool(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>self, index: int) ‑> ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Indexes into the list. The first element has index 0.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>The index to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The value at the given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item(self, index: int) -&gt; TSource:
    &#34;&#34;&#34;Indexes into the list. The first element has index 0.

    Args:
        index: The index to retrieve.

    Returns:
        The value at the given index.
    &#34;&#34;&#34;
    return self[index]</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, mapping: Callable[[TSource], TResult]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]</span>
</code></dt>
<dd>
<div class="desc"><p>Map list.</p>
<p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>The function to transform elements from the input
list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list of transformed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, mapping: Callable[[TSource], TResult]) -&gt; FrozenList[TResult]:
    &#34;&#34;&#34;Map list.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection.

    Args:
        mapping: The function to transform elements from the input
            list.

    Returns:
        The list of transformed elements.
    &#34;&#34;&#34;
    return FrozenList((*builtins.map(mapping, self),))</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.mapi"><code class="name flex">
<span>def <span class="ident">mapi</span></span>(<span>self, mapping: Callable[[int, TSource], TResult]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]</span>
</code></dt>
<dd>
<div class="desc"><p>Map list with index.</p>
<p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection. The integer index passed to the function indicates
the index (from 0) of element being transformed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>The function to transform elements and their
indices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list of transformed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mapi(self, mapping: Callable[[int, TSource], TResult]) -&gt; FrozenList[TResult]:
    &#34;&#34;&#34;Map list with index.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection. The integer index passed to the function indicates
    the index (from 0) of element being transformed.

    Args:
        mapping: The function to transform elements and their
            indices.

    Returns:
        The list of transformed elements.
    &#34;&#34;&#34;
    return FrozenList((*itertools.starmap(mapping, enumerate(self)),))</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, pattern: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, pattern: Any) -&gt; Any:
    case: Case[TSource] = Case(self)
    return case(pattern) if pattern else case</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, *args: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pipe list through the given functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, *args: Any) -&gt; Any:
    &#34;&#34;&#34;Pipe list through the given functions.&#34;&#34;&#34;
    return pipe(self, *args)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self, count: int) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list after removing the first N elements.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of elements to skip.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list after removing the first N elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(self, count: int) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Returns the list after removing the first N elements.

    Args:
        count: The number of elements to skip.

    Returns:
        The list after removing the first N elements.
    &#34;&#34;&#34;
    return FrozenList(self.value[count:])</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.skip_last"><code class="name flex">
<span>def <span class="ident">skip_last</span></span>(<span>self, count: int) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip_last(self, count: int) -&gt; FrozenList[TSource]:
    return FrozenList(self.value[:-count])</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Return tail of List.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Return tail of List.&#34;&#34;&#34;

    _, *tail = self.value
    return FrozenList(tail)</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>self, count: int) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first N elements of the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to take.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(self, count: int) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Returns the first N elements of the list.

    Args:
        count: The number of items to take.

    Returns:
        The result list.
    &#34;&#34;&#34;
    return FrozenList(self.value[:count])</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.take_last"><code class="name flex">
<span>def <span class="ident">take_last</span></span>(<span>self, count: int) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a specified number of contiguous elements from the
end of the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to take.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_last(self, count: int) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Returns a specified number of contiguous elements from the
    end of the list.

    Args:
        count: The number of items to take.

    Returns:
        The result list.
    &#34;&#34;&#34;
    return FrozenList(self.value[-count:])</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.try_head"><code class="name flex">
<span>def <span class="ident">try_head</span></span>(<span>self) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first element of the list, or None if the list is
empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_head(self) -&gt; Option[TSource]:
    &#34;&#34;&#34;Returns the first element of the list, or None if the list is
    empty.
    &#34;&#34;&#34;
    if self.value:
        value = cast(&#34;TSource&#34;, self.value[0])
        return Some(value)

    return Nothing</code></pre>
</details>
</dd>
<dt id="expression.collections.FrozenList.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self, other: <a title="expression.collections.FrozenList" href="#expression.collections.FrozenList">FrozenList</a>[TResult]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[~TSource, ~TResult]]</span>
</code></dt>
<dd>
<div class="desc"><p>Combines the two lists into a list of pairs. The two lists
must have equal lengths. .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>The second input list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A single list containing pairs of matching elements from the
input lists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self, other: FrozenList[TResult]) -&gt; FrozenList[Tuple[TSource, TResult]]:
    &#34;&#34;&#34;Combines the two lists into a list of pairs. The two lists
    must have equal lengths. .

    Args:
        other: The second input list.

    Returns:
        A single list containing pairs of matching elements from the
        input lists.
    &#34;&#34;&#34;
    return of_seq(builtins.zip(self.value, other.value))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="expression.collections.Map"><code class="flex name class">
<span>class <span class="ident">Map</span></span>
</code></dt>
<dd>
<div class="desc"><p>The immutable map class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Map(Mapping[Key, Value]):
    &#34;&#34;&#34;The immutable map class.&#34;&#34;&#34;

    def __init__(self, __tree: Optional[MapTree[Key, Value]] = None) -&gt; None:
        self._tree: MapTree[Key, Value] = __tree if __tree else maptree.empty

    def add(self, key: Key, value: Value) -&gt; Map[Key, Value]:
        return Map(maptree.add(key, value, self._tree))

    @overload
    def pipe(self, __fn1: Callable[[Map[Key, Value]], Result]) -&gt; Result:
        ...

    @overload
    def pipe(self, __fn1: Callable[[Map[Key, Value]], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(self, __fn1: Callable[[Map[Key, Value]], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[Map[Key, Value]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[Map[Key, Value]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
    ) -&gt; T5:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[Map[Key, Value]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
        __fn6: Callable[[T5], T6],
    ) -&gt; T6:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe map through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    @staticmethod
    def create(ie: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        return create(ie)

    def contains_key(self, key: Key) -&gt; bool:
        return maptree.mem(key, self._tree)

    def change(self, key: Key, f: Callable[[Option[Value]], Option[Value]]) -&gt; Map[Key, Value]:
        return Map(maptree.change(key, f, self._tree))

    @staticmethod
    def empty() -&gt; Map[Key, Value]:
        return Map(maptree.empty)

    def is_empty(self) -&gt; bool:
        return maptree.is_empty(self._tree)

    def exists(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        return maptree.exists(predicate, self._tree)

    def filter(self, predicate: Callable[[Key, Value], bool]) -&gt; Map[Key, Value]:
        return Map(maptree.filter(predicate, self._tree))

    def for_all(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        &#34;&#34;&#34;Returns true if the given predicate returns true for all of
        the bindings in the map.

        Args:
            predicate: The function to test the input elements.

        Returns:
            True if the predicate evaluates to true for all of the
            bindings in the map.
        &#34;&#34;&#34;
        return maptree.forall(predicate, self._tree)

    def iterate(self, f: Callable[[Key, Value], None]) -&gt; None:
        return maptree.iter(f, self._tree)

    #     def MapRange (f:&#39;Value-&gt;&#39;Result) =
    #         return Map&lt;&#39;Key, &#39;Result&gt;(comparer, maptree.map f tree)

    def fold(self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Result:
        return maptree.fold(folder, state, self._tree)

    def fold_back(self, folder: Callable[[Tuple[Key, Value], Result], Result], state: Result) -&gt; Result:
        return maptree.fold_back(folder, self._tree, state)

    def map(self, mapping: Callable[[Key, Value], Result]) -&gt; Map[Key, Result]:
        &#34;&#34;&#34;Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection. The key passed to the function indicates the key of
        element being transformed.

        Args:
            mapping: The function to transform the key/value pairs

        Returns:
            The resulting map of keys and transformed values.
        &#34;&#34;&#34;
        return Map(maptree.map(mapping, self._tree))

    def partition(self, predicate: Callable[[Key, Value], bool]) -&gt; Tuple[Map[Key, Value], Map[Key, Value]]:
        r1, r2 = maptree.partition(predicate, self._tree)
        return Map(r1), Map(r2)

    # @overload
    # def get(self, key: Key) -&gt; Optional[Value]:
    #    ...

    # @overload
    # def get(self, key: Key, default: Value) -&gt; Value:
    #    ...

    # def get(self, key: Key, default: Union[Value, _T]) -&gt; Union[Value, _T]:
    #    for value in self.try_find(key):
    #        return value

    #   return default

    def items(self) -&gt; Set[Tuple[Key, Value]]:
        return set(maptree.to_seq(self._tree))

    def remove(self, key: Key) -&gt; Map[Key, Value]:
        return Map(maptree.remove(key, self._tree))

    def to_list(self) -&gt; FrozenList[Tuple[Key, Value]]:
        return maptree.to_list(self._tree)

    def to_seq(self) -&gt; Iterable[Tuple[Key, Value]]:
        &#34;&#34;&#34;Convert to sequence.

        Returns:
            Sequence of key, value tuples.
        &#34;&#34;&#34;
        return maptree.to_seq(self._tree)

    def try_get_value(self, key: Key, value: List[Value]):
        for v in maptree.try_find(key, self._tree).to_list():
            value.append(v)
            return True
        else:
            return False

    def try_find(self, key: Key) -&gt; Option[Value]:
        return maptree.try_find(key, self._tree)

    def try_pick(self, chooser: Callable[[Key, Value], Option[Result]]) -&gt; Option[Result]:
        return maptree.try_pick(chooser, self._tree)

    @staticmethod
    def of(**args: Value) -&gt; Map[str, Value]:
        return Map(maptree.of_seq(args.items()))

    @staticmethod
    def of_frozenlist(lst: FrozenList[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Generate map from list.

        Returns:
            The new map.
        &#34;&#34;&#34;
        return of_frozenlist((lst))

    @staticmethod
    def of_list(lst: List[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Generate map from list.

        Returns:
            The new map.
        &#34;&#34;&#34;
        return of_list((lst))

    @staticmethod
    def of_seq(sequence: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Generate map from sequence.

        Generates a new map from an iterable of key/value tuples. This
        is an alias for `Map.create`.

        Returns:
            The new map.
        &#34;&#34;&#34;
        return of_seq(sequence)

    def __hash__(self) -&gt; int:
        def combine_hash(x: int, y: int) -&gt; int:
            return (x &lt;&lt; 1) + y + 631

        res = 0
        for x, y in maptree.mk_iterator(self._tree):
            res = combine_hash(res, hash(x))
            res = combine_hash(res, hash(y))
        return res

    def __getitem__(self, k: Key) -&gt; Value:
        return maptree.find(k, self._tree)

    def __iter__(self) -&gt; Iterator[Key]:
        xs = maptree.mk_iterator(self._tree)
        return (k for (k, _) in xs)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the number of bindings in the map.&#34;&#34;&#34;
        return maptree.size(self._tree)

    def __contains__(self, o: Any) -&gt; bool:
        return self.contains_key(o)

    def __eq__(self, o: Any) -&gt; bool:
        if not isinstance(o, Map):
            return False

        other = cast(Map[Any, Any], o)
        iterator: Iterator[Tuple[Any, Any]] = iter(other.to_seq())

        for kv in self.to_seq():
            try:
                kv_other = next(iterator)
            except StopIteration:
                return False
            else:
                if kv != kv_other:
                    return False
        return True

    def __bool__(self) -&gt; bool:
        return not maptree.is_empty(self._tree)

    def __str__(self) -&gt; str:
        def to_str(item: Tuple[Key, Value]) -&gt; str:
            key, value = item
            if isinstance(key, str):
                return f&#39;(&#34;{key}&#34;, {value})&#39;
            return f&#34;({key}, {value})&#34;

        items = pipe(self.to_seq(), seq.map(to_str))
        return f&#34;map [{&#39;; &#39;.join(items)}]&#34;

    def __repr__(self) -&gt; str:
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="expression.collections.Map.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>ie: Iterable[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create(ie: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return create(ie)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty() -&gt; Map[Key, Value]:
    return Map(maptree.empty)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>**args: Value) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of(**args: Value) -&gt; Map[str, Value]:
    return Map(maptree.of_seq(args.items()))</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.of_frozenlist"><code class="name flex">
<span>def <span class="ident">of_frozenlist</span></span>(<span>lst: <a title="expression.collections.FrozenList" href="#expression.collections.FrozenList">FrozenList</a>[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate map from list.</p>
<h2 id="returns">Returns</h2>
<p>The new map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of_frozenlist(lst: FrozenList[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    &#34;&#34;&#34;Generate map from list.

    Returns:
        The new map.
    &#34;&#34;&#34;
    return of_frozenlist((lst))</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.of_list"><code class="name flex">
<span>def <span class="ident">of_list</span></span>(<span>lst: List[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate map from list.</p>
<h2 id="returns">Returns</h2>
<p>The new map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of_list(lst: List[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    &#34;&#34;&#34;Generate map from list.

    Returns:
        The new map.
    &#34;&#34;&#34;
    return of_list((lst))</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.of_seq"><code class="name flex">
<span>def <span class="ident">of_seq</span></span>(<span>sequence: Iterable[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate map from sequence.</p>
<p>Generates a new map from an iterable of key/value tuples. This
is an alias for <code><a title="expression.collections.Map.create" href="#expression.collections.Map.create">Map.create()</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>The new map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of_seq(sequence: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    &#34;&#34;&#34;Generate map from sequence.

    Generates a new map from an iterable of key/value tuples. This
    is an alias for `Map.create`.

    Returns:
        The new map.
    &#34;&#34;&#34;
    return of_seq(sequence)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="expression.collections.Map.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, key: Key, value: Value) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, key: Key, value: Value) -&gt; Map[Key, Value]:
    return Map(maptree.add(key, value, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.change"><code class="name flex">
<span>def <span class="ident">change</span></span>(<span>self, key: Key, f: Callable[[Option[Value]], Option[Value]]) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change(self, key: Key, f: Callable[[Option[Value]], Option[Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.change(key, f, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.contains_key"><code class="name flex">
<span>def <span class="ident">contains_key</span></span>(<span>self, key: Key) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_key(self, key: Key) -&gt; bool:
    return maptree.mem(key, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, predicate: Callable[[Key, Value], bool]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
    return maptree.exists(predicate, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, predicate: Callable[[Key, Value], bool]) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, predicate: Callable[[Key, Value], bool]) -&gt; Map[Key, Value]:
    return Map(maptree.filter(predicate, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) ‑> ~Result</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Result:
    return maptree.fold(folder, state, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.fold_back"><code class="name flex">
<span>def <span class="ident">fold_back</span></span>(<span>self, folder: Callable[[Tuple[Key, Value], Result], Result], state: Result) ‑> ~Result</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold_back(self, folder: Callable[[Tuple[Key, Value], Result], Result], state: Result) -&gt; Result:
    return maptree.fold_back(folder, self._tree, state)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.for_all"><code class="name flex">
<span>def <span class="ident">for_all</span></span>(<span>self, predicate: Callable[[Key, Value], bool]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the given predicate returns true for all of
the bindings in the map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>The function to test the input elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the predicate evaluates to true for all of the
bindings in the map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def for_all(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
    &#34;&#34;&#34;Returns true if the given predicate returns true for all of
    the bindings in the map.

    Args:
        predicate: The function to test the input elements.

    Returns:
        True if the predicate evaluates to true for all of the
        bindings in the map.
    &#34;&#34;&#34;
    return maptree.forall(predicate, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self) -&gt; bool:
    return maptree.is_empty(self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self) ‑> Set[Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>D.items() -&gt; a set-like object providing a view on D's items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self) -&gt; Set[Tuple[Key, Value]]:
    return set(maptree.to_seq(self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.iterate"><code class="name flex">
<span>def <span class="ident">iterate</span></span>(<span>self, f: Callable[[Key, Value], None]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterate(self, f: Callable[[Key, Value], None]) -&gt; None:
    return maptree.iter(f, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, mapping: Callable[[Key, Value], Result]) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection. The key passed to the function indicates the key of
element being transformed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>The function to transform the key/value pairs</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resulting map of keys and transformed values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, mapping: Callable[[Key, Value], Result]) -&gt; Map[Key, Result]:
    &#34;&#34;&#34;Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection. The key passed to the function indicates the key of
    element being transformed.

    Args:
        mapping: The function to transform the key/value pairs

    Returns:
        The resulting map of keys and transformed values.
    &#34;&#34;&#34;
    return Map(maptree.map(mapping, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>self, predicate: Callable[[Key, Value], bool]) ‑> Tuple[<a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a>[~Key, ~Value], <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(self, predicate: Callable[[Key, Value], bool]) -&gt; Tuple[Map[Key, Value], Map[Key, Value]]:
    r1, r2 = maptree.partition(predicate, self._tree)
    return Map(r1), Map(r2)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, *args: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pipe map through the given functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, *args: Any) -&gt; Any:
    &#34;&#34;&#34;Pipe map through the given functions.&#34;&#34;&#34;
    return pipe(self, *args)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, key: Key) ‑> <a title="expression.collections.map.Map" href="map.html#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, key: Key) -&gt; Map[Key, Value]:
    return Map(maptree.remove(key, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>self) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(self) -&gt; FrozenList[Tuple[Key, Value]]:
    return maptree.to_list(self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.to_seq"><code class="name flex">
<span>def <span class="ident">to_seq</span></span>(<span>self) ‑> Iterable[Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to sequence.</p>
<h2 id="returns">Returns</h2>
<p>Sequence of key, value tuples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_seq(self) -&gt; Iterable[Tuple[Key, Value]]:
    &#34;&#34;&#34;Convert to sequence.

    Returns:
        Sequence of key, value tuples.
    &#34;&#34;&#34;
    return maptree.to_seq(self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.try_find"><code class="name flex">
<span>def <span class="ident">try_find</span></span>(<span>self, key: Key) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_find(self, key: Key) -&gt; Option[Value]:
    return maptree.try_find(key, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.try_get_value"><code class="name flex">
<span>def <span class="ident">try_get_value</span></span>(<span>self, key: Key, value: List[Value])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_get_value(self, key: Key, value: List[Value]):
    for v in maptree.try_find(key, self._tree).to_list():
        value.append(v)
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="expression.collections.Map.try_pick"><code class="name flex">
<span>def <span class="ident">try_pick</span></span>(<span>self, chooser: Callable[[Key, Value], Option[Result]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_pick(self, chooser: Callable[[Key, Value], Option[Result]]) -&gt; Option[Result]:
    return maptree.try_pick(chooser, self._tree)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="expression.collections.Seq"><code class="flex name class">
<span>class <span class="ident">Seq</span></span>
<span>(</span><span>iterable: Iterable[TSource] = [])</span>
</code></dt>
<dd>
<div class="desc"><p>Sequence type.</p>
<p>Contains instance methods for dot-chaining operators methods on
sequences.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; xs = Seq([1, 2, 3])
&gt;&gt;&gt; ys = xs.map(lambda x: x + 1).filter(lambda x: x &lt; 3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Seq(Iterable[TSource]):
    &#34;&#34;&#34;Sequence type.

    Contains instance methods for dot-chaining operators methods on
    sequences.

    Example:
        &gt;&gt;&gt; xs = Seq([1, 2, 3])
        &gt;&gt;&gt; ys = xs.map(lambda x: x + 1).filter(lambda x: x &lt; 3)
    &#34;&#34;&#34;

    def __init__(self, iterable: Iterable[TSource] = []) -&gt; None:
        self._value = iterable

    @classmethod
    def of(cls, *args: TSource) -&gt; Seq[TSource]:
        return cls(args)

    @classmethod
    def of_iterable(cls, source: Iterable[TSource]) -&gt; Seq[TSource]:
        return cls(source)

    def append(self, *others: Iterable[TSource]) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Wraps the two given enumerations as a single concatenated
        enumeration.&#34;&#34;&#34;
        return Seq(concat(self._value, *others))

    def filter(self, predicate: Callable[[TSource], bool]) -&gt; Seq[TSource]:
        return Seq(filter(predicate)(self))

    def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; Seq[TResult]:
        &#34;&#34;&#34;Choose items from the sequence.

        Applies the given function to each element of the list. Returns
        the list comprised of the results x for each element where the
        function returns `Some(x)`.

        Args:
            chooser: The function to generate options from the elements.

        Returns:
            The list comprising the values selected from the chooser
            function.
        &#34;&#34;&#34;

        xs = pipe(self, choose(chooser))
        return Seq(xs)

    def collect(self, mapping: Callable[[TSource], &#34;Seq[TResult]&#34;]) -&gt; Seq[TResult]:
        xs = pipe(self, collect(mapping))
        return Seq(xs)

    @staticmethod
    def delay(generator: Callable[[], Iterable[TSource]]) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Returns a sequence that is built from the given delayed specification of a
        sequence.

        The input function is evaluated each time an IEnumerator for the sequence
        is requested.

        Args:
            generator: The generating function for the sequence.
        &#34;&#34;&#34;

        return delay(generator)

    @staticmethod
    def empty() -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns empty sequence.&#34;&#34;&#34;
        return Seq()

    def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
        &#34;&#34;&#34;Applies a function to each element of the collection,
        threading an accumulator argument through the computation. If
        the input function is f and the elements are i0...iN then
        computes f (... (f s i0)...) iN

        Args:
            folder: A function that updates the state with each element
                from the sequence.
            state: The initial state.
        Returns:
            The state object after the folding function is applied to
            each element of the sequence.
        &#34;&#34;&#34;
        return functools.reduce(folder, self, state)  # type: ignore

    def head(self) -&gt; TSource:
        &#34;&#34;&#34;Returns the first element of the sequence.&#34;&#34;&#34;

        return head(self)

    def length(self) -&gt; int:
        &#34;&#34;&#34;Returns the length of the sequence.&#34;&#34;&#34;
        return length(self)

    def map(self, mapper: Callable[[TSource], TResult]) -&gt; Seq[TResult]:
        &#34;&#34;&#34;Map sequence.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection.

        Args:
            mapping: A function to transform items from the input sequence.

        Returns:
            The result sequence.
        &#34;&#34;&#34;

        return Seq(pipe(self, map(mapper)))

    def mapi(self, mapping: Callable[[int, TSource], TResult]) -&gt; Seq[TResult]:
        &#34;&#34;&#34;Map list with index.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection. The integer index passed to the function indicates
        the index (from 0) of element being transformed.

        Args:
            mapping: The function to transform elements and their
                indices.

        Returns:
            The list of transformed elements.
        &#34;&#34;&#34;
        return Seq(mapi(mapping)(self))

    @overload
    def match(self) -&gt; Case[Iterable[TSource]]:
        ...

    @overload
    def match(self, pattern: Any) -&gt; Iterable[Iterable[TSource]]:
        ...

    def match(self, pattern: Optional[Any] = None) -&gt; Any:
        case: Case[Iterable[TSource]] = Case(self)
        return case(pattern) if pattern else case

    @overload
    def pipe(self, __fn1: Callable[[&#34;Seq[TSource]&#34;], TResult]) -&gt; TResult:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;Seq[TSource]&#34;], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;Seq[TSource]&#34;], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;Seq[TSource]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe sequence through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    @overload
    @staticmethod
    def range(stop: int) -&gt; Iterable[int]:
        ...

    @overload
    @staticmethod
    def range(start: int, stop: int) -&gt; Iterable[int]:
        ...

    @overload
    @staticmethod
    def range(start: int, stop: int, step: int) -&gt; Iterable[int]:
        ...

    @staticmethod
    def range(*args: int, **kw: int) -&gt; Iterable[int]:
        return range(*args, **kw)

    def scan(self, scanner: Callable[[TState, TSource], TState], state: TState) -&gt; Iterable[TState]:
        &#34;&#34;&#34;Like fold, but computes on-demand and returns the sequence of
        intermediary and final results.

        Args:
            scanner: A function that updates the state with each element
                from the sequence.
            state: The initial state.

        Returns:
            The resulting sequence of computed states.
        &#34;&#34;&#34;
        return Seq(itertools.accumulate(self._value, scanner, initial=state))

    def skip(self, count: int) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns a sequence that skips N elements of the underlying
        sequence and then yields the remaining elements of the sequence.

        Args:
            count: The number of items to skip.
        &#34;&#34;&#34;
        return Seq(pipe(self, skip(count)))

    def sum(self) -&gt; TSource:
        &#34;&#34;&#34;Returns the sum of the elements in the sequence.&#34;&#34;&#34;
        return sum(self)

    def sum_by(self, projection: Callable[[TSource], TResult]) -&gt; TResult:
        &#34;&#34;&#34;Returns the sum of the results generated by applying the
        function to each element of the sequence.&#34;&#34;&#34;
        return pipe(self, sum_by(projection))

    def tail(self) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns a sequence that skips 1 element of the underlying
        sequence and then yields the remaining elements of the
        sequence.&#34;&#34;&#34;
        return self.skip(1)

    def take(self, count: int) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns the first N elements of the sequence.

        Args:
            count: The number of items to take.
        &#34;&#34;&#34;
        return Seq(pipe(self, take(count)))

    def to_list(self) -&gt; &#34;FrozenList[TSource]&#34;:
        return to_list(self)

    @classmethod
    def unfold(cls, generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Returns a list that contains the elements generated by the
        given computation. The given initial state argument is passed to
        the element generator.

        Args:
            generator: A function that takes in the current state and
                returns an option tuple of the next element of the list
                and the next state value.
            state: The initial state.

        Returns:
            The result list.
        &#34;&#34;&#34;

        return pipe(state, unfold(generator))

    def zip(self, other: Iterable[TResult]) -&gt; Iterable[Tuple[TSource, TResult]]:
        &#34;&#34;&#34;Combines the two sequences into a list of pairs. The two
        sequences need not have equal lengths: when one sequence is
        exhausted any remaining elements in the other sequence are
        ignored.

        Args:
            other: The second input sequence.

        Returns:
            The result sequence.
        &#34;&#34;&#34;
        return builtins.zip(self, other)

    def __iter__(self) -&gt; Iterator[TSource]:
        &#34;&#34;&#34;Return iterator for sequence.&#34;&#34;&#34;
        return builtins.iter(self._value)

    def __repr__(self) -&gt; str:
        result = &#34;[&#34;

        for count, x in enumerate(self):
            if count == 0:
                result += str(x)

            elif count == 100:
                result += &#34;; ...&#34;
                break

            else:
                result += &#34;; &#34; + str(x)

        return result + &#34;]&#34;

    def __str__(self) -&gt; str:
        return repr(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Iterable</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="expression.collections.Seq.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>generator: Callable[[], Iterable[TSource]]) ‑> Iterable[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that is built from the given delayed specification of a
sequence.</p>
<p>The input function is evaluated each time an IEnumerator for the sequence
is requested.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>The generating function for the sequence.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def delay(generator: Callable[[], Iterable[TSource]]) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Returns a sequence that is built from the given delayed specification of a
    sequence.

    The input function is evaluated each time an IEnumerator for the sequence
    is requested.

    Args:
        generator: The generating function for the sequence.
    &#34;&#34;&#34;

    return delay(generator)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns empty sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty() -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns empty sequence.&#34;&#34;&#34;
    return Seq()</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>*args: TSource) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(cls, *args: TSource) -&gt; Seq[TSource]:
    return cls(args)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.of_iterable"><code class="name flex">
<span>def <span class="ident">of_iterable</span></span>(<span>source: Iterable[TSource]) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of_iterable(cls, source: Iterable[TSource]) -&gt; Seq[TSource]:
    return cls(source)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>*args: int, **kw: int) ‑> Iterable[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def range(*args: int, **kw: int) -&gt; Iterable[int]:
    return range(*args, **kw)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.unfold"><code class="name flex">
<span>def <span class="ident">unfold</span></span>(<span>generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) ‑> Iterable[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list that contains the elements generated by the
given computation. The given initial state argument is passed to
the element generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>A function that takes in the current state and
returns an option tuple of the next element of the list
and the next state value.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def unfold(cls, generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Returns a list that contains the elements generated by the
    given computation. The given initial state argument is passed to
    the element generator.

    Args:
        generator: A function that takes in the current state and
            returns an option tuple of the next element of the list
            and the next state value.
        state: The initial state.

    Returns:
        The result list.
    &#34;&#34;&#34;

    return pipe(state, unfold(generator))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="expression.collections.Seq.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, *others: Iterable[TSource]) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Wraps the two given enumerations as a single concatenated
enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, *others: Iterable[TSource]) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Wraps the two given enumerations as a single concatenated
    enumeration.&#34;&#34;&#34;
    return Seq(concat(self._value, *others))</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.choose"><code class="name flex">
<span>def <span class="ident">choose</span></span>(<span>self, chooser: Callable[[TSource], Option[TResult]]) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Choose items from the sequence.</p>
<p>Applies the given function to each element of the list. Returns
the list comprised of the results x for each element where the
function returns <code>Some(x)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chooser</code></strong></dt>
<dd>The function to generate options from the elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list comprising the values selected from the chooser
function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; Seq[TResult]:
    &#34;&#34;&#34;Choose items from the sequence.

    Applies the given function to each element of the list. Returns
    the list comprised of the results x for each element where the
    function returns `Some(x)`.

    Args:
        chooser: The function to generate options from the elements.

    Returns:
        The list comprising the values selected from the chooser
        function.
    &#34;&#34;&#34;

    xs = pipe(self, choose(chooser))
    return Seq(xs)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.collect"><code class="name flex">
<span>def <span class="ident">collect</span></span>(<span>self, mapping: "Callable[[TSource], '<a title="expression.collections.Seq" href="#expression.collections.Seq">Seq</a>[TResult]']") ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect(self, mapping: Callable[[TSource], &#34;Seq[TResult]&#34;]) -&gt; Seq[TResult]:
    xs = pipe(self, collect(mapping))
    return Seq(xs)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, predicate: Callable[[TSource], bool]) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, predicate: Callable[[TSource], bool]) -&gt; Seq[TSource]:
    return Seq(filter(predicate)(self))</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, folder: Callable[[TState, TSource], TState], state: TState) ‑> ~TState</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a function to each element of the collection,
threading an accumulator argument through the computation. If
the input function is f and the elements are i0&hellip;iN then
computes f (&hellip; (f s i0)&hellip;) iN</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder</code></strong></dt>
<dd>A function that updates the state with each element
from the sequence.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The state object after the folding function is applied to
each element of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
    &#34;&#34;&#34;Applies a function to each element of the collection,
    threading an accumulator argument through the computation. If
    the input function is f and the elements are i0...iN then
    computes f (... (f s i0)...) iN

    Args:
        folder: A function that updates the state with each element
            from the sequence.
        state: The initial state.
    Returns:
        The state object after the folding function is applied to
        each element of the sequence.
    &#34;&#34;&#34;
    return functools.reduce(folder, self, state)  # type: ignore</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self) ‑> ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first element of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self) -&gt; TSource:
    &#34;&#34;&#34;Returns the first element of the sequence.&#34;&#34;&#34;

    return head(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.length"><code class="name flex">
<span>def <span class="ident">length</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the length of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length(self) -&gt; int:
    &#34;&#34;&#34;Returns the length of the sequence.&#34;&#34;&#34;
    return length(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, mapper: Callable[[TSource], TResult]) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Map sequence.</p>
<p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>A function to transform items from the input sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, mapper: Callable[[TSource], TResult]) -&gt; Seq[TResult]:
    &#34;&#34;&#34;Map sequence.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection.

    Args:
        mapping: A function to transform items from the input sequence.

    Returns:
        The result sequence.
    &#34;&#34;&#34;

    return Seq(pipe(self, map(mapper)))</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.mapi"><code class="name flex">
<span>def <span class="ident">mapi</span></span>(<span>self, mapping: Callable[[int, TSource], TResult]) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Map list with index.</p>
<p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection. The integer index passed to the function indicates
the index (from 0) of element being transformed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>The function to transform elements and their
indices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list of transformed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mapi(self, mapping: Callable[[int, TSource], TResult]) -&gt; Seq[TResult]:
    &#34;&#34;&#34;Map list with index.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection. The integer index passed to the function indicates
    the index (from 0) of element being transformed.

    Args:
        mapping: The function to transform elements and their
            indices.

    Returns:
        The list of transformed elements.
    &#34;&#34;&#34;
    return Seq(mapi(mapping)(self))</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, pattern: Optional[Any] = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, pattern: Optional[Any] = None) -&gt; Any:
    case: Case[Iterable[TSource]] = Case(self)
    return case(pattern) if pattern else case</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, *args: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pipe sequence through the given functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, *args: Any) -&gt; Any:
    &#34;&#34;&#34;Pipe sequence through the given functions.&#34;&#34;&#34;
    return pipe(self, *args)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>self, scanner: Callable[[TState, TSource], TState], state: TState) ‑> Iterable[~TState]</span>
</code></dt>
<dd>
<div class="desc"><p>Like fold, but computes on-demand and returns the sequence of
intermediary and final results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scanner</code></strong></dt>
<dd>A function that updates the state with each element
from the sequence.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resulting sequence of computed states.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan(self, scanner: Callable[[TState, TSource], TState], state: TState) -&gt; Iterable[TState]:
    &#34;&#34;&#34;Like fold, but computes on-demand and returns the sequence of
    intermediary and final results.

    Args:
        scanner: A function that updates the state with each element
            from the sequence.
        state: The initial state.

    Returns:
        The resulting sequence of computed states.
    &#34;&#34;&#34;
    return Seq(itertools.accumulate(self._value, scanner, initial=state))</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self, count: int) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that skips N elements of the underlying
sequence and then yields the remaining elements of the sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to skip.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(self, count: int) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns a sequence that skips N elements of the underlying
    sequence and then yields the remaining elements of the sequence.

    Args:
        count: The number of items to skip.
    &#34;&#34;&#34;
    return Seq(pipe(self, skip(count)))</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>self) ‑> ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of the elements in the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(self) -&gt; TSource:
    &#34;&#34;&#34;Returns the sum of the elements in the sequence.&#34;&#34;&#34;
    return sum(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.sum_by"><code class="name flex">
<span>def <span class="ident">sum_by</span></span>(<span>self, projection: Callable[[TSource], TResult]) ‑> ~TResult</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of the results generated by applying the
function to each element of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_by(self, projection: Callable[[TSource], TResult]) -&gt; TResult:
    &#34;&#34;&#34;Returns the sum of the results generated by applying the
    function to each element of the sequence.&#34;&#34;&#34;
    return pipe(self, sum_by(projection))</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that skips 1 element of the underlying
sequence and then yields the remaining elements of the
sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns a sequence that skips 1 element of the underlying
    sequence and then yields the remaining elements of the
    sequence.&#34;&#34;&#34;
    return self.skip(1)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>self, count: int) ‑> <a title="expression.collections.seq.Seq" href="seq.html#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first N elements of the sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to take.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(self, count: int) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns the first N elements of the sequence.

    Args:
        count: The number of items to take.
    &#34;&#34;&#34;
    return Seq(pipe(self, take(count)))</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>self) ‑> '<a title="expression.collections.FrozenList" href="#expression.collections.FrozenList">FrozenList</a>[TSource]'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(self) -&gt; &#34;FrozenList[TSource]&#34;:
    return to_list(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.Seq.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self, other: Iterable[TResult]) ‑> Iterable[Tuple[~TSource, ~TResult]]</span>
</code></dt>
<dd>
<div class="desc"><p>Combines the two sequences into a list of pairs. The two
sequences need not have equal lengths: when one sequence is
exhausted any remaining elements in the other sequence are
ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>The second input sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self, other: Iterable[TResult]) -&gt; Iterable[Tuple[TSource, TResult]]:
    &#34;&#34;&#34;Combines the two sequences into a list of pairs. The two
    sequences need not have equal lengths: when one sequence is
    exhausted any remaining elements in the other sequence are
    ignored.

    Args:
        other: The second input sequence.

    Returns:
        The result sequence.
    &#34;&#34;&#34;
    return builtins.zip(self, other)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="expression" href="../index.html">expression</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="expression.collections.asyncseq" href="asyncseq.html">expression.collections.asyncseq</a></code></li>
<li><code><a title="expression.collections.frozenlist" href="frozenlist.html">expression.collections.frozenlist</a></code></li>
<li><code><a title="expression.collections.map" href="map.html">expression.collections.map</a></code></li>
<li><code><a title="expression.collections.maptree" href="maptree.html">expression.collections.maptree</a></code></li>
<li><code><a title="expression.collections.seq" href="seq.html">expression.collections.seq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="expression.collections.FrozenList" href="#expression.collections.FrozenList">FrozenList</a></code></h4>
<ul class="two-column">
<li><code><a title="expression.collections.FrozenList.append" href="#expression.collections.FrozenList.append">append</a></code></li>
<li><code><a title="expression.collections.FrozenList.choose" href="#expression.collections.FrozenList.choose">choose</a></code></li>
<li><code><a title="expression.collections.FrozenList.collect" href="#expression.collections.FrozenList.collect">collect</a></code></li>
<li><code><a title="expression.collections.FrozenList.cons" href="#expression.collections.FrozenList.cons">cons</a></code></li>
<li><code><a title="expression.collections.FrozenList.empty" href="#expression.collections.FrozenList.empty">empty</a></code></li>
<li><code><a title="expression.collections.FrozenList.filter" href="#expression.collections.FrozenList.filter">filter</a></code></li>
<li><code><a title="expression.collections.FrozenList.fold" href="#expression.collections.FrozenList.fold">fold</a></code></li>
<li><code><a title="expression.collections.FrozenList.forall" href="#expression.collections.FrozenList.forall">forall</a></code></li>
<li><code><a title="expression.collections.FrozenList.head" href="#expression.collections.FrozenList.head">head</a></code></li>
<li><code><a title="expression.collections.FrozenList.indexed" href="#expression.collections.FrozenList.indexed">indexed</a></code></li>
<li><code><a title="expression.collections.FrozenList.is_empty" href="#expression.collections.FrozenList.is_empty">is_empty</a></code></li>
<li><code><a title="expression.collections.FrozenList.item" href="#expression.collections.FrozenList.item">item</a></code></li>
<li><code><a title="expression.collections.FrozenList.map" href="#expression.collections.FrozenList.map">map</a></code></li>
<li><code><a title="expression.collections.FrozenList.mapi" href="#expression.collections.FrozenList.mapi">mapi</a></code></li>
<li><code><a title="expression.collections.FrozenList.match" href="#expression.collections.FrozenList.match">match</a></code></li>
<li><code><a title="expression.collections.FrozenList.of" href="#expression.collections.FrozenList.of">of</a></code></li>
<li><code><a title="expression.collections.FrozenList.of_option" href="#expression.collections.FrozenList.of_option">of_option</a></code></li>
<li><code><a title="expression.collections.FrozenList.of_seq" href="#expression.collections.FrozenList.of_seq">of_seq</a></code></li>
<li><code><a title="expression.collections.FrozenList.pipe" href="#expression.collections.FrozenList.pipe">pipe</a></code></li>
<li><code><a title="expression.collections.FrozenList.range" href="#expression.collections.FrozenList.range">range</a></code></li>
<li><code><a title="expression.collections.FrozenList.singleton" href="#expression.collections.FrozenList.singleton">singleton</a></code></li>
<li><code><a title="expression.collections.FrozenList.skip" href="#expression.collections.FrozenList.skip">skip</a></code></li>
<li><code><a title="expression.collections.FrozenList.skip_last" href="#expression.collections.FrozenList.skip_last">skip_last</a></code></li>
<li><code><a title="expression.collections.FrozenList.tail" href="#expression.collections.FrozenList.tail">tail</a></code></li>
<li><code><a title="expression.collections.FrozenList.take" href="#expression.collections.FrozenList.take">take</a></code></li>
<li><code><a title="expression.collections.FrozenList.take_last" href="#expression.collections.FrozenList.take_last">take_last</a></code></li>
<li><code><a title="expression.collections.FrozenList.try_head" href="#expression.collections.FrozenList.try_head">try_head</a></code></li>
<li><code><a title="expression.collections.FrozenList.unfold" href="#expression.collections.FrozenList.unfold">unfold</a></code></li>
<li><code><a title="expression.collections.FrozenList.zip" href="#expression.collections.FrozenList.zip">zip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="expression.collections.Map" href="#expression.collections.Map">Map</a></code></h4>
<ul class="two-column">
<li><code><a title="expression.collections.Map.add" href="#expression.collections.Map.add">add</a></code></li>
<li><code><a title="expression.collections.Map.change" href="#expression.collections.Map.change">change</a></code></li>
<li><code><a title="expression.collections.Map.contains_key" href="#expression.collections.Map.contains_key">contains_key</a></code></li>
<li><code><a title="expression.collections.Map.create" href="#expression.collections.Map.create">create</a></code></li>
<li><code><a title="expression.collections.Map.empty" href="#expression.collections.Map.empty">empty</a></code></li>
<li><code><a title="expression.collections.Map.exists" href="#expression.collections.Map.exists">exists</a></code></li>
<li><code><a title="expression.collections.Map.filter" href="#expression.collections.Map.filter">filter</a></code></li>
<li><code><a title="expression.collections.Map.fold" href="#expression.collections.Map.fold">fold</a></code></li>
<li><code><a title="expression.collections.Map.fold_back" href="#expression.collections.Map.fold_back">fold_back</a></code></li>
<li><code><a title="expression.collections.Map.for_all" href="#expression.collections.Map.for_all">for_all</a></code></li>
<li><code><a title="expression.collections.Map.is_empty" href="#expression.collections.Map.is_empty">is_empty</a></code></li>
<li><code><a title="expression.collections.Map.items" href="#expression.collections.Map.items">items</a></code></li>
<li><code><a title="expression.collections.Map.iterate" href="#expression.collections.Map.iterate">iterate</a></code></li>
<li><code><a title="expression.collections.Map.map" href="#expression.collections.Map.map">map</a></code></li>
<li><code><a title="expression.collections.Map.of" href="#expression.collections.Map.of">of</a></code></li>
<li><code><a title="expression.collections.Map.of_frozenlist" href="#expression.collections.Map.of_frozenlist">of_frozenlist</a></code></li>
<li><code><a title="expression.collections.Map.of_list" href="#expression.collections.Map.of_list">of_list</a></code></li>
<li><code><a title="expression.collections.Map.of_seq" href="#expression.collections.Map.of_seq">of_seq</a></code></li>
<li><code><a title="expression.collections.Map.partition" href="#expression.collections.Map.partition">partition</a></code></li>
<li><code><a title="expression.collections.Map.pipe" href="#expression.collections.Map.pipe">pipe</a></code></li>
<li><code><a title="expression.collections.Map.remove" href="#expression.collections.Map.remove">remove</a></code></li>
<li><code><a title="expression.collections.Map.to_list" href="#expression.collections.Map.to_list">to_list</a></code></li>
<li><code><a title="expression.collections.Map.to_seq" href="#expression.collections.Map.to_seq">to_seq</a></code></li>
<li><code><a title="expression.collections.Map.try_find" href="#expression.collections.Map.try_find">try_find</a></code></li>
<li><code><a title="expression.collections.Map.try_get_value" href="#expression.collections.Map.try_get_value">try_get_value</a></code></li>
<li><code><a title="expression.collections.Map.try_pick" href="#expression.collections.Map.try_pick">try_pick</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="expression.collections.Seq" href="#expression.collections.Seq">Seq</a></code></h4>
<ul class="two-column">
<li><code><a title="expression.collections.Seq.append" href="#expression.collections.Seq.append">append</a></code></li>
<li><code><a title="expression.collections.Seq.choose" href="#expression.collections.Seq.choose">choose</a></code></li>
<li><code><a title="expression.collections.Seq.collect" href="#expression.collections.Seq.collect">collect</a></code></li>
<li><code><a title="expression.collections.Seq.delay" href="#expression.collections.Seq.delay">delay</a></code></li>
<li><code><a title="expression.collections.Seq.empty" href="#expression.collections.Seq.empty">empty</a></code></li>
<li><code><a title="expression.collections.Seq.filter" href="#expression.collections.Seq.filter">filter</a></code></li>
<li><code><a title="expression.collections.Seq.fold" href="#expression.collections.Seq.fold">fold</a></code></li>
<li><code><a title="expression.collections.Seq.head" href="#expression.collections.Seq.head">head</a></code></li>
<li><code><a title="expression.collections.Seq.length" href="#expression.collections.Seq.length">length</a></code></li>
<li><code><a title="expression.collections.Seq.map" href="#expression.collections.Seq.map">map</a></code></li>
<li><code><a title="expression.collections.Seq.mapi" href="#expression.collections.Seq.mapi">mapi</a></code></li>
<li><code><a title="expression.collections.Seq.match" href="#expression.collections.Seq.match">match</a></code></li>
<li><code><a title="expression.collections.Seq.of" href="#expression.collections.Seq.of">of</a></code></li>
<li><code><a title="expression.collections.Seq.of_iterable" href="#expression.collections.Seq.of_iterable">of_iterable</a></code></li>
<li><code><a title="expression.collections.Seq.pipe" href="#expression.collections.Seq.pipe">pipe</a></code></li>
<li><code><a title="expression.collections.Seq.range" href="#expression.collections.Seq.range">range</a></code></li>
<li><code><a title="expression.collections.Seq.scan" href="#expression.collections.Seq.scan">scan</a></code></li>
<li><code><a title="expression.collections.Seq.skip" href="#expression.collections.Seq.skip">skip</a></code></li>
<li><code><a title="expression.collections.Seq.sum" href="#expression.collections.Seq.sum">sum</a></code></li>
<li><code><a title="expression.collections.Seq.sum_by" href="#expression.collections.Seq.sum_by">sum_by</a></code></li>
<li><code><a title="expression.collections.Seq.tail" href="#expression.collections.Seq.tail">tail</a></code></li>
<li><code><a title="expression.collections.Seq.take" href="#expression.collections.Seq.take">take</a></code></li>
<li><code><a title="expression.collections.Seq.to_list" href="#expression.collections.Seq.to_list">to_list</a></code></li>
<li><code><a title="expression.collections.Seq.unfold" href="#expression.collections.Seq.unfold">unfold</a></code></li>
<li><code><a title="expression.collections.Seq.zip" href="#expression.collections.Seq.zip">zip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.3.dev5+gbec6307</a>.</p>
</footer>
</body>
</html>