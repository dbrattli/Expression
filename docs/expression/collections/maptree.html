<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>expression.collections.maptree API documentation</title>
<meta name="description" content="The maptree module …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>expression.collections.maptree</code></h1>
</header>
<section id="section-intro">
<p>The maptree module.</p>
<p>Contains the internal tree implementation of the <code><a title="expression.collections.maptree.map" href="#expression.collections.maptree.map">map()</a></code>.</p>
<p>Do not use directly. Use the <code><a title="expression.collections.maptree.map" href="#expression.collections.maptree.map">map()</a></code> module instead.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Attribution to original authors of this code
# --------------------------------------------
# This code has been originally been ported from the Fable project which
# was originally ported from the FSharp project.
#
# Fable:
#   https://fable.io
# - Copyright (c) Alfonso Garcia-Caro and contributors.
# - MIT License
# - https://github.com/fable-compiler/Fable/blob/nagareyama/src/fable-library/Map.fs
#
# F#
# - https://github.com/dotnet/fsharp
# - Copyright (c) Microsoft Corporation. All Rights Reserved.
# - MIT License
# - https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/map.fs

&#34;&#34;&#34;
The maptree module.

Contains the internal tree implementation of the `map`.

Do not use directly. Use the `map` module instead.
&#34;&#34;&#34;
import builtins
from dataclasses import dataclass
from typing import Any, Callable, Generic, Iterable, Iterator, Tuple, TypeVar, cast

from expression.core import Nothing, Option, Some, failwith, pipe

from . import frozenlist, seq
from .frozenlist import FrozenList

Key = TypeVar(&#34;Key&#34;)
Value = TypeVar(&#34;Value&#34;)
Result = TypeVar(&#34;Result&#34;)


@dataclass
class MapTreeLeaf(Generic[Key, Value]):
    key: Key
    value: Value


MapTree = Option[MapTreeLeaf[Key, Value]]


@dataclass
class MapTreeNode(MapTreeLeaf[Key, Value]):
    left: MapTree[Key, Value]
    right: MapTree[Key, Value]

    height: int


empty: MapTree[Any, Any] = Nothing


def is_empty(m: MapTree[Key, Value]):
    return m.is_none()


def size_aux(acc: int, m: MapTree[Key, Value]) -&gt; int:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            return size_aux(size_aux(acc + 1, mn.left), mn.right)
        else:
            return acc + 1
    else:
        return acc


def size(x: MapTree[Key, Value]):
    return size_aux(0, x)


def height(m: MapTree[Key, Value]) -&gt; int:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            return mn.height
        else:
            return 1
    else:
        return 0


TOLERANCE = 2


def mk(left: MapTree[Key, Value], key: Key, value: Value, right: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    hl = height(left)
    hr = height(right)
    m = hr if hl &lt; hr else hl
    if m == 0:  # m=0 ~ is_empty(l) and is_empty(r)
        return Some(MapTreeLeaf(key, value))
    else:
        return Some(MapTreeNode(key, value, left, right, m + 1))  # new map is higher by 1 than the highest


def rebalance(t1: MapTree[Key, Value], k: Key, v: Value, t2: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    t1h = height(t1)
    t2h = height(t2)
    if t2h &gt; t1h + TOLERANCE:  # right is heavier than left
        if isinstance(t2.value, MapTreeNode):
            t2_ = cast(MapTreeNode[Key, Value], t2.value)
            # One of the nodes must have height &gt; height t1 + 1
            if height(t2_.left) &gt; t1h + 1:  # balance left: combination
                if isinstance(t2_.left.value, MapTreeNode):
                    t2l = cast(MapTreeNode[Key, Value], t2_.left.value)

                    return mk(mk(t1, k, v, t2l.left), t2l.key, t2l.value, mk(t2l.right, t2_.key, t2_.value, t2_.right))
                else:
                    failwith(&#34;internal error: Map.rebalance&#34;)
            else:  # Rotate left
                return mk(mk(t1, k, v, t2_.left), t2_.key, t2_.value, t2_.right)
        else:
            failwith(&#34;internal error: Map.rebalance&#34;)
    else:
        if t1h &gt; t2h + TOLERANCE:  # left is heavier than right
            if isinstance(t1.value, MapTreeNode):
                t1_ = cast(MapTreeNode[Key, Value], t1.value)
                # One of the nodes must have height &gt; height t2 + 1
                if height(t1_.right) &gt; t2h + 1:  # balance right: combination
                    if isinstance(t1_.right.value, MapTreeNode):
                        t1r = cast(MapTreeNode[Key, Value], t1_.right.value)
                        return mk(
                            mk(t1_.left, t1_.key, t1_.value, t1r.left), t1r.key, t1r.value, mk(t1r.right, k, v, t2)
                        )
                    else:
                        failwith(&#34;internal error: Map.rebalance&#34;)
                else:
                    return mk(t1_.left, t1_.key, t1_.value, mk(t1_.right, k, v, t2))
            else:
                failwith(&#34;internal error: Map.rebalance&#34;)
        else:
            return mk(t1, k, v, t2)


def add(k: Key, v: Value, m: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if k &lt; mn.key:
                return rebalance(add(k, v, mn.left), mn.key, mn.value, mn.right)
            elif k == mn.key:
                return Some(MapTreeNode(k, v, mn.left, mn.right, mn.height))
            else:
                return rebalance(mn.left, mn.key, mn.value, add(k, v, mn.right))
        else:
            if k &lt; m2.key:
                return Some(MapTreeNode(k, v, empty, m, 2))
            elif k == m2:
                return Some(MapTreeLeaf(k, v))
            else:
                return Some(MapTreeNode(k, v, m, empty, 2))
    else:
        return Some(MapTreeLeaf(k, v))


def try_find(k: Key, m: MapTree[Key, Value]) -&gt; Option[Value]:
    for m2 in m.to_list():
        if k == m2.key:
            return Some(m2.value)
        else:
            if isinstance(m2, MapTreeNode):
                mn = cast(MapTreeNode[Key, Value], m2)
                return try_find(k, mn.left if k &lt; m2 else mn.right)
            else:
                return Nothing
    else:  # Nothing
        return Nothing


def find(k: Key, m: MapTree[Key, Value]) -&gt; Value:
    for v in try_find(k, m).to_list():
        return v
    else:
        raise KeyError(&#34;Key not found&#34;)


def partition1(
    predicate: Callable[[Key, Value], bool], k: Key, v: Value, acc: Tuple[MapTree[Key, Value], MapTree[Key, Value]]
) -&gt; Tuple[MapTree[Key, Value], MapTree[Key, Value]]:
    (acc1, acc2) = acc
    if predicate(k, v):
        return add(k, v, acc1), acc2
    else:
        return acc1, add(k, v, acc2)


def partition_aux(
    predicate: Callable[[Key, Value], bool],
    m: MapTree[Key, Value],
    acc: Tuple[MapTree[Key, Value], MapTree[Key, Value]],
) -&gt; Tuple[MapTree[Key, Value], MapTree[Key, Value]]:
    for m2 in m:
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            acc = partition_aux(predicate, mn.right, acc)
            acc = partition1(predicate, mn.key, mn.value, acc)
            return partition_aux(predicate, mn.left, acc)
        else:
            return partition1(predicate, m2.key, m2.value, acc)
    else:  # Nothing
        return acc


def partition(
    predicate: Callable[[Key, Value], bool], m: MapTree[Key, Value]
) -&gt; Tuple[MapTree[Key, Value], MapTree[Key, Value]]:
    return partition_aux(predicate, m, (empty, empty))


def filter1(predicate: Callable[[Key, Value], bool], k: Key, v: Value, acc: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    if predicate(k, v):
        return add(k, v, acc)
    else:
        return acc


def filter_aux(
    predicate: Callable[[Key, Value], bool], m: MapTree[Key, Value], acc: MapTree[Key, Value]
) -&gt; MapTree[Key, Value]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            acc = filter_aux(predicate, mn.left, acc)
            acc = filter1(predicate, mn.key, mn.value, acc)
            return filter_aux(predicate, mn.right, acc)
        else:
            return filter1(predicate, m2.key, m2.value, acc)
    else:  # Nothing
        return acc


def filter(f: Callable[[Key, Value], bool], m: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    return filter_aux(f, m, empty)


def splice_out_successor(m: MapTree[Key, Value]) -&gt; Tuple[Key, Value, Option[MapTreeLeaf[Key, Value]]]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if is_empty(mn.left):
                return mn.key, mn.value, mn.right
            else:
                k3, v3, l_ = splice_out_successor(mn.left)
                return k3, v3, mk(l_, mn.key, mn.value, mn.right)
        else:
            return m2.key, m2.value, empty
    else:  # Nothing
        failwith(&#34;internal error: Map.splice_out_successor&#34;)


def remove(k: Key, m: MapTree[Key, Value]) -&gt; Option[MapTreeLeaf[Key, Value]]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if k &lt; mn.key:
                return rebalance(remove(k, mn.left), mn.key, mn.value, mn.right)
            elif k == mn.key:
                if is_empty(mn.left):
                    return mn.right
                elif is_empty(mn.right):
                    return mn.left
                else:
                    sk, sv, r_ = splice_out_successor(mn.right)
                    return mk(mn.left, sk, sv, r_)
            else:
                return rebalance(mn.left, mn.key, mn.value, remove(k, mn.right))
        else:
            if k == m2.key:
                return empty
            else:
                return m
    else:  # Nothing
        return empty


def change(k: Key, u: Callable[[Option[Value]], Option[Value]], m: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if k &lt; mn.key:
                rebalance(change(k, u, mn.left), mn.key, mn.value, mn.right)
            elif k == mn.key:
                for v in u(Some(mn.value)).to_list():
                    return Some(MapTreeNode(k, v, mn.left, mn.right, mn.height))
                else:
                    if is_empty(mn.left):
                        return mn.right
                    elif is_empty(mn.right):
                        return mn.left
                    else:
                        sk, sv, r_ = splice_out_successor(mn.right)
                        return mk(mn.left, sk, sv, r_)
            else:
                rebalance(mn.left, mn.key, mn.value, change(k, u, mn.right))
        else:
            if k &lt; m2.key:
                for v in u(Nothing).to_list():
                    return Some(MapTreeNode(k, v, empty, m, 2))
                else:
                    return m
            elif k == m2.key:
                for v in u(Some(m2.value)).to_list():
                    return Some(MapTreeLeaf(k, v))
                else:
                    return empty
            else:
                for v in u(Nothing).to_list():
                    return Some(MapTreeNode(k, v, m, empty, 2))
                else:
                    return m

    else:
        for v in u(Nothing):
            return Some(MapTreeLeaf(k, v))
        else:
            return m


def mem(k: Key, m: MapTree[Key, Value]) -&gt; bool:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if k &lt; mn.key:
                return mem(k, mn.left)
            else:
                return k == mn.key or mem(k, mn.right)
        else:
            return k == m2.key
    else:
        return False


def iter(fn: Callable[[Key, Value], None], m: MapTree[Key, Value]) -&gt; None:
    &#34;&#34;&#34;Iterate maptree.&#34;&#34;&#34;
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            iter(fn, mn.left)
            fn(mn.key, mn.value)
            iter(fn, mn.right)
        else:
            fn(m2.key, m2.value)


def try_pick(f: Callable[[Key, Value], Option[Result]], m: MapTree[Key, Value]) -&gt; Option[Result]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            for res in try_pick(f, mn.left).to_list():
                return res
            else:
                for res in f(mn.key, mn.value):
                    return res
                else:
                    return try_pick(f, mn.right)
        else:
            return f(m2.key, m2.value)
    else:
        return Nothing


def exists(f: Callable[[Key, Value], bool], m: MapTree[Key, Value]) -&gt; bool:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            return exists(f, mn.left) or f(mn.key, mn.value) or exists(f, mn.right)
        else:
            return f(m2.key, m2.value)
    else:
        return False


def forall(f: Callable[[Key, Value], bool], m: MapTree[Key, Value]) -&gt; bool:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            return forall(f, mn.left) and f(mn.key, mn.value) and forall(f, mn.right)
        else:
            return f(m2.key, m2.value)
    else:
        return True


def map(f: Callable[[Value], Result], m: MapTree[Key, Value]) -&gt; MapTree[Key, Result]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            l2 = map(f, mn.left)
            v2 = f(mn.value)
            r2 = map(f, mn.right)
            return Some(MapTreeNode(mn.key, v2, l2, r2, mn.height))
        else:
            return Some(MapTreeLeaf(m2.key, f(m2.value)))
    else:
        return empty


def mapi(f: Callable[[Tuple[Key, Value]], Result], m: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            l2 = mapi(f, mn.left)
            v2 = f((mn.key, mn.value))
            r2 = mapi(f, mn.right)
            return Some(MapTreeNode(mn.key, v2, l2, r2, mn.height))
        else:
            return Some(MapTreeLeaf(m2.key, f((m2.key, m2.value))))
    else:
        return empty


def fold_back(f: Callable[[Tuple[Key, Value], Result], Result], m: MapTree[Key, Value], x: Result) -&gt; Result:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            x = fold_back(f, mn.right, x)
            x = f((mn.key, mn.value), x)
            return fold_back(f, mn.left, x)
        else:
            return f((m2.key, m2.value), x)
    else:
        return x


def fold(f: Callable[[Result, Tuple[Key, Value]], Result], x: Result, m: MapTree[Key, Value]) -&gt; Result:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            x = fold(f, x, mn.left)
            x = f(x, (mn.key, mn.value))
            return fold(f, x, mn.right)
        else:
            return f(x, (m2.key, m2.value))
    else:
        return x


def to_list(m: MapTree[Key, Value]) -&gt; FrozenList[Tuple[Key, Value]]:
    def loop(m: MapTree[Key, Value], acc: FrozenList[Tuple[Key, Value]]) -&gt; FrozenList[Tuple[Key, Value]]:
        for m2 in m.to_list():
            if isinstance(m2, MapTreeNode):
                mn = cast(MapTreeNode[Key, Value], m2)
                return loop(mn.left, loop(mn.right, acc).cons((mn.key, mn.value)))
            else:
                return acc.cons((m2.key, m2.value))
        else:
            return acc

    return loop(m, frozenlist.empty)


def of_list(xs: FrozenList[Tuple[Key, Value]]) -&gt; MapTree[Key, Value]:
    def folder(acc: MapTree[Key, Value], kv: Tuple[Key, Value]):
        k, v = kv
        return add(k, v, acc)

    return xs.fold(folder, empty)


def mk_from_iterator(acc: MapTree[Key, Value], e: Iterator[Tuple[Key, Value]]) -&gt; MapTree[Key, Value]:
    try:
        (x, y) = next(e)
    except StopIteration:
        return acc
    else:
        return mk_from_iterator(add(x, y, acc), e)


def of_seq(xs: Iterable[Tuple[Key, Value]]) -&gt; MapTree[Key, Value]:
    if isinstance(xs, FrozenList):
        xs = cast(FrozenList[Tuple[Key, Value]], xs)
        return of_list(xs)
    else:
        ie = builtins.iter(xs)
        return mk_from_iterator(empty, ie)


# Imperative left-to-right iterators.

# collapseLHS:
# a) Always returns either [] or a list starting with MapOne.
# b) The &#34;fringe&#34; of the set stack is unchanged.
def collapseLHS(stack: FrozenList[MapTree[Key, Value]]) -&gt; FrozenList[MapTree[Key, Value]]:
    if stack.is_empty():
        return frozenlist.empty
    m, rest = stack.head(), stack.tail()
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            tree = Some(MapTreeLeaf(mn.key, mn.value))
            return collapseLHS(rest.cons(mn.right).cons(tree).cons(mn.left))
        else:
            return stack
    else:
        return collapseLHS(rest)


class MkIterator(Iterator[Tuple[Key, Value]]):
    def __init__(self, m: MapTree[Key, Value]) -&gt; None:
        self.stack = collapseLHS(frozenlist.singleton(m))

    def __next__(self) -&gt; Tuple[Key, Value]:
        if not self.stack:
            raise StopIteration

        rest = self.stack.tail()
        for m in self.stack.head():
            if isinstance(m, MapTreeNode):
                failwith(&#34;Please report error: Map iterator, unexpected stack for next()&#34;)
            else:
                self.stack = collapseLHS(rest)
                return m.key, m.value
        else:
            failwith(&#34;Please report error: Map iterator, unexpected stack for next()&#34;)


def not_started() -&gt; None:
    failwith(&#34;enumeration not started&#34;)


def already_finished():
    failwith(&#34;enumeration already finished&#34;)


def mk_iterator(m: MapTree[Key, Value]) -&gt; Iterator[Tuple[Key, Value]]:
    return MkIterator(m)


def to_seq(s: MapTree[Key, Value]) -&gt; Iterable[Tuple[Key, Value]]:
    it = mk_iterator(s)

    def folder(it: Iterator[Tuple[Key, Value]]):
        try:
            current = next(it)
        except StopIteration:
            return Nothing
        else:
            return Some((current, it))

    return pipe(it, seq.unfold(folder))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="expression.collections.maptree.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>k: ~Key, v: ~Value, m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(k: Key, v: Value, m: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if k &lt; mn.key:
                return rebalance(add(k, v, mn.left), mn.key, mn.value, mn.right)
            elif k == mn.key:
                return Some(MapTreeNode(k, v, mn.left, mn.right, mn.height))
            else:
                return rebalance(mn.left, mn.key, mn.value, add(k, v, mn.right))
        else:
            if k &lt; m2.key:
                return Some(MapTreeNode(k, v, empty, m, 2))
            elif k == m2:
                return Some(MapTreeLeaf(k, v))
            else:
                return Some(MapTreeNode(k, v, m, empty, 2))
    else:
        return Some(MapTreeLeaf(k, v))</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.already_finished"><code class="name flex">
<span>def <span class="ident">already_finished</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def already_finished():
    failwith(&#34;enumeration already finished&#34;)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.change"><code class="name flex">
<span>def <span class="ident">change</span></span>(<span>k: ~Key, u: Callable[[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change(k: Key, u: Callable[[Option[Value]], Option[Value]], m: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if k &lt; mn.key:
                rebalance(change(k, u, mn.left), mn.key, mn.value, mn.right)
            elif k == mn.key:
                for v in u(Some(mn.value)).to_list():
                    return Some(MapTreeNode(k, v, mn.left, mn.right, mn.height))
                else:
                    if is_empty(mn.left):
                        return mn.right
                    elif is_empty(mn.right):
                        return mn.left
                    else:
                        sk, sv, r_ = splice_out_successor(mn.right)
                        return mk(mn.left, sk, sv, r_)
            else:
                rebalance(mn.left, mn.key, mn.value, change(k, u, mn.right))
        else:
            if k &lt; m2.key:
                for v in u(Nothing).to_list():
                    return Some(MapTreeNode(k, v, empty, m, 2))
                else:
                    return m
            elif k == m2.key:
                for v in u(Some(m2.value)).to_list():
                    return Some(MapTreeLeaf(k, v))
                else:
                    return empty
            else:
                for v in u(Nothing).to_list():
                    return Some(MapTreeNode(k, v, m, empty, 2))
                else:
                    return m

    else:
        for v in u(Nothing):
            return Some(MapTreeLeaf(k, v))
        else:
            return m</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.collapseLHS"><code class="name flex">
<span>def <span class="ident">collapseLHS</span></span>(<span>stack: <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collapseLHS(stack: FrozenList[MapTree[Key, Value]]) -&gt; FrozenList[MapTree[Key, Value]]:
    if stack.is_empty():
        return frozenlist.empty
    m, rest = stack.head(), stack.tail()
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            tree = Some(MapTreeLeaf(mn.key, mn.value))
            return collapseLHS(rest.cons(mn.right).cons(tree).cons(mn.left))
        else:
            return stack
    else:
        return collapseLHS(rest)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>f: Callable[[~Key, ~Value], bool], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(f: Callable[[Key, Value], bool], m: MapTree[Key, Value]) -&gt; bool:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            return exists(f, mn.left) or f(mn.key, mn.value) or exists(f, mn.right)
        else:
            return f(m2.key, m2.value)
    else:
        return False</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>f: Callable[[~Key, ~Value], bool], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(f: Callable[[Key, Value], bool], m: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    return filter_aux(f, m, empty)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.filter1"><code class="name flex">
<span>def <span class="ident">filter1</span></span>(<span>predicate: Callable[[~Key, ~Value], bool], k: ~Key, v: ~Value, acc: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter1(predicate: Callable[[Key, Value], bool], k: Key, v: Value, acc: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    if predicate(k, v):
        return add(k, v, acc)
    else:
        return acc</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.filter_aux"><code class="name flex">
<span>def <span class="ident">filter_aux</span></span>(<span>predicate: Callable[[~Key, ~Value], bool], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], acc: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_aux(
    predicate: Callable[[Key, Value], bool], m: MapTree[Key, Value], acc: MapTree[Key, Value]
) -&gt; MapTree[Key, Value]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            acc = filter_aux(predicate, mn.left, acc)
            acc = filter1(predicate, mn.key, mn.value, acc)
            return filter_aux(predicate, mn.right, acc)
        else:
            return filter1(predicate, m2.key, m2.value, acc)
    else:  # Nothing
        return acc</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>k: ~Key, m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> ~Value</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(k: Key, m: MapTree[Key, Value]) -&gt; Value:
    for v in try_find(k, m).to_list():
        return v
    else:
        raise KeyError(&#34;Key not found&#34;)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>f: Callable[[~Result, Tuple[~Key, ~Value]], ~Result], x: ~Result, m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> ~Result</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(f: Callable[[Result, Tuple[Key, Value]], Result], x: Result, m: MapTree[Key, Value]) -&gt; Result:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            x = fold(f, x, mn.left)
            x = f(x, (mn.key, mn.value))
            return fold(f, x, mn.right)
        else:
            return f(x, (m2.key, m2.value))
    else:
        return x</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.fold_back"><code class="name flex">
<span>def <span class="ident">fold_back</span></span>(<span>f: Callable[[Tuple[~Key, ~Value], ~Result], ~Result], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], x: ~Result) ‑> ~Result</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold_back(f: Callable[[Tuple[Key, Value], Result], Result], m: MapTree[Key, Value], x: Result) -&gt; Result:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            x = fold_back(f, mn.right, x)
            x = f((mn.key, mn.value), x)
            return fold_back(f, mn.left, x)
        else:
            return f((m2.key, m2.value), x)
    else:
        return x</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.forall"><code class="name flex">
<span>def <span class="ident">forall</span></span>(<span>f: Callable[[~Key, ~Value], bool], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forall(f: Callable[[Key, Value], bool], m: MapTree[Key, Value]) -&gt; bool:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            return forall(f, mn.left) and f(mn.key, mn.value) and forall(f, mn.right)
        else:
            return f(m2.key, m2.value)
    else:
        return True</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.height"><code class="name flex">
<span>def <span class="ident">height</span></span>(<span>m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def height(m: MapTree[Key, Value]) -&gt; int:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            return mn.height
        else:
            return 1
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(m: MapTree[Key, Value]):
    return m.is_none()</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.iter"><code class="name flex">
<span>def <span class="ident">iter</span></span>(<span>fn: Callable[[~Key, ~Value], NoneType], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate maptree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter(fn: Callable[[Key, Value], None], m: MapTree[Key, Value]) -&gt; None:
    &#34;&#34;&#34;Iterate maptree.&#34;&#34;&#34;
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            iter(fn, mn.left)
            fn(mn.key, mn.value)
            iter(fn, mn.right)
        else:
            fn(m2.key, m2.value)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>f: Callable[[~Value], ~Result], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Result]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(f: Callable[[Value], Result], m: MapTree[Key, Value]) -&gt; MapTree[Key, Result]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            l2 = map(f, mn.left)
            v2 = f(mn.value)
            r2 = map(f, mn.right)
            return Some(MapTreeNode(mn.key, v2, l2, r2, mn.height))
        else:
            return Some(MapTreeLeaf(m2.key, f(m2.value)))
    else:
        return empty</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.mapi"><code class="name flex">
<span>def <span class="ident">mapi</span></span>(<span>f: Callable[[Tuple[~Key, ~Value]], ~Result], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mapi(f: Callable[[Tuple[Key, Value]], Result], m: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            l2 = mapi(f, mn.left)
            v2 = f((mn.key, mn.value))
            r2 = mapi(f, mn.right)
            return Some(MapTreeNode(mn.key, v2, l2, r2, mn.height))
        else:
            return Some(MapTreeLeaf(m2.key, f((m2.key, m2.value))))
    else:
        return empty</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.mem"><code class="name flex">
<span>def <span class="ident">mem</span></span>(<span>k: ~Key, m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mem(k: Key, m: MapTree[Key, Value]) -&gt; bool:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if k &lt; mn.key:
                return mem(k, mn.left)
            else:
                return k == mn.key or mem(k, mn.right)
        else:
            return k == m2.key
    else:
        return False</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.mk"><code class="name flex">
<span>def <span class="ident">mk</span></span>(<span>left: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], key: ~Key, value: ~Value, right: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk(left: MapTree[Key, Value], key: Key, value: Value, right: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    hl = height(left)
    hr = height(right)
    m = hr if hl &lt; hr else hl
    if m == 0:  # m=0 ~ is_empty(l) and is_empty(r)
        return Some(MapTreeLeaf(key, value))
    else:
        return Some(MapTreeNode(key, value, left, right, m + 1))  # new map is higher by 1 than the highest</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.mk_from_iterator"><code class="name flex">
<span>def <span class="ident">mk_from_iterator</span></span>(<span>acc: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], e: Iterator[Tuple[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_from_iterator(acc: MapTree[Key, Value], e: Iterator[Tuple[Key, Value]]) -&gt; MapTree[Key, Value]:
    try:
        (x, y) = next(e)
    except StopIteration:
        return acc
    else:
        return mk_from_iterator(add(x, y, acc), e)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.mk_iterator"><code class="name flex">
<span>def <span class="ident">mk_iterator</span></span>(<span>m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> Iterator[Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mk_iterator(m: MapTree[Key, Value]) -&gt; Iterator[Tuple[Key, Value]]:
    return MkIterator(m)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.not_started"><code class="name flex">
<span>def <span class="ident">not_started</span></span>(<span>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_started() -&gt; None:
    failwith(&#34;enumeration not started&#34;)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.of_list"><code class="name flex">
<span>def <span class="ident">of_list</span></span>(<span>xs: <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_list(xs: FrozenList[Tuple[Key, Value]]) -&gt; MapTree[Key, Value]:
    def folder(acc: MapTree[Key, Value], kv: Tuple[Key, Value]):
        k, v = kv
        return add(k, v, acc)

    return xs.fold(folder, empty)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.of_seq"><code class="name flex">
<span>def <span class="ident">of_seq</span></span>(<span>xs: Iterable[Tuple[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_seq(xs: Iterable[Tuple[Key, Value]]) -&gt; MapTree[Key, Value]:
    if isinstance(xs, FrozenList):
        xs = cast(FrozenList[Tuple[Key, Value]], xs)
        return of_list(xs)
    else:
        ie = builtins.iter(xs)
        return mk_from_iterator(empty, ie)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>predicate: Callable[[~Key, ~Value], bool], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> Tuple[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(
    predicate: Callable[[Key, Value], bool], m: MapTree[Key, Value]
) -&gt; Tuple[MapTree[Key, Value], MapTree[Key, Value]]:
    return partition_aux(predicate, m, (empty, empty))</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.partition1"><code class="name flex">
<span>def <span class="ident">partition1</span></span>(<span>predicate: Callable[[~Key, ~Value], bool], k: ~Key, v: ~Value, acc: Tuple[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]]) ‑> Tuple[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition1(
    predicate: Callable[[Key, Value], bool], k: Key, v: Value, acc: Tuple[MapTree[Key, Value], MapTree[Key, Value]]
) -&gt; Tuple[MapTree[Key, Value], MapTree[Key, Value]]:
    (acc1, acc2) = acc
    if predicate(k, v):
        return add(k, v, acc1), acc2
    else:
        return acc1, add(k, v, acc2)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.partition_aux"><code class="name flex">
<span>def <span class="ident">partition_aux</span></span>(<span>predicate: Callable[[~Key, ~Value], bool], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], acc: Tuple[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]]) ‑> Tuple[<a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition_aux(
    predicate: Callable[[Key, Value], bool],
    m: MapTree[Key, Value],
    acc: Tuple[MapTree[Key, Value], MapTree[Key, Value]],
) -&gt; Tuple[MapTree[Key, Value], MapTree[Key, Value]]:
    for m2 in m:
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            acc = partition_aux(predicate, mn.right, acc)
            acc = partition1(predicate, mn.key, mn.value, acc)
            return partition_aux(predicate, mn.left, acc)
        else:
            return partition1(predicate, m2.key, m2.value, acc)
    else:  # Nothing
        return acc</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.rebalance"><code class="name flex">
<span>def <span class="ident">rebalance</span></span>(<span>t1: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], k: ~Key, v: ~Value, t2: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rebalance(t1: MapTree[Key, Value], k: Key, v: Value, t2: MapTree[Key, Value]) -&gt; MapTree[Key, Value]:
    t1h = height(t1)
    t2h = height(t2)
    if t2h &gt; t1h + TOLERANCE:  # right is heavier than left
        if isinstance(t2.value, MapTreeNode):
            t2_ = cast(MapTreeNode[Key, Value], t2.value)
            # One of the nodes must have height &gt; height t1 + 1
            if height(t2_.left) &gt; t1h + 1:  # balance left: combination
                if isinstance(t2_.left.value, MapTreeNode):
                    t2l = cast(MapTreeNode[Key, Value], t2_.left.value)

                    return mk(mk(t1, k, v, t2l.left), t2l.key, t2l.value, mk(t2l.right, t2_.key, t2_.value, t2_.right))
                else:
                    failwith(&#34;internal error: Map.rebalance&#34;)
            else:  # Rotate left
                return mk(mk(t1, k, v, t2_.left), t2_.key, t2_.value, t2_.right)
        else:
            failwith(&#34;internal error: Map.rebalance&#34;)
    else:
        if t1h &gt; t2h + TOLERANCE:  # left is heavier than right
            if isinstance(t1.value, MapTreeNode):
                t1_ = cast(MapTreeNode[Key, Value], t1.value)
                # One of the nodes must have height &gt; height t2 + 1
                if height(t1_.right) &gt; t2h + 1:  # balance right: combination
                    if isinstance(t1_.right.value, MapTreeNode):
                        t1r = cast(MapTreeNode[Key, Value], t1_.right.value)
                        return mk(
                            mk(t1_.left, t1_.key, t1_.value, t1r.left), t1r.key, t1r.value, mk(t1r.right, k, v, t2)
                        )
                    else:
                        failwith(&#34;internal error: Map.rebalance&#34;)
                else:
                    return mk(t1_.left, t1_.key, t1_.value, mk(t1_.right, k, v, t2))
            else:
                failwith(&#34;internal error: Map.rebalance&#34;)
        else:
            return mk(t1, k, v, t2)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>k: ~Key, m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(k: Key, m: MapTree[Key, Value]) -&gt; Option[MapTreeLeaf[Key, Value]]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if k &lt; mn.key:
                return rebalance(remove(k, mn.left), mn.key, mn.value, mn.right)
            elif k == mn.key:
                if is_empty(mn.left):
                    return mn.right
                elif is_empty(mn.right):
                    return mn.left
                else:
                    sk, sv, r_ = splice_out_successor(mn.right)
                    return mk(mn.left, sk, sv, r_)
            else:
                return rebalance(mn.left, mn.key, mn.value, remove(k, mn.right))
        else:
            if k == m2.key:
                return empty
            else:
                return m
    else:  # Nothing
        return empty</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>x: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(x: MapTree[Key, Value]):
    return size_aux(0, x)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.size_aux"><code class="name flex">
<span>def <span class="ident">size_aux</span></span>(<span>acc: int, m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_aux(acc: int, m: MapTree[Key, Value]) -&gt; int:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            return size_aux(size_aux(acc + 1, mn.left), mn.right)
        else:
            return acc + 1
    else:
        return acc</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.splice_out_successor"><code class="name flex">
<span>def <span class="ident">splice_out_successor</span></span>(<span>m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> Tuple[~Key, ~Value, <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splice_out_successor(m: MapTree[Key, Value]) -&gt; Tuple[Key, Value, Option[MapTreeLeaf[Key, Value]]]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            if is_empty(mn.left):
                return mn.key, mn.value, mn.right
            else:
                k3, v3, l_ = splice_out_successor(mn.left)
                return k3, v3, mk(l_, mn.key, mn.value, mn.right)
        else:
            return m2.key, m2.value, empty
    else:  # Nothing
        failwith(&#34;internal error: Map.splice_out_successor&#34;)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(m: MapTree[Key, Value]) -&gt; FrozenList[Tuple[Key, Value]]:
    def loop(m: MapTree[Key, Value], acc: FrozenList[Tuple[Key, Value]]) -&gt; FrozenList[Tuple[Key, Value]]:
        for m2 in m.to_list():
            if isinstance(m2, MapTreeNode):
                mn = cast(MapTreeNode[Key, Value], m2)
                return loop(mn.left, loop(mn.right, acc).cons((mn.key, mn.value)))
            else:
                return acc.cons((m2.key, m2.value))
        else:
            return acc

    return loop(m, frozenlist.empty)</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.to_seq"><code class="name flex">
<span>def <span class="ident">to_seq</span></span>(<span>s: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> Iterable[Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_seq(s: MapTree[Key, Value]) -&gt; Iterable[Tuple[Key, Value]]:
    it = mk_iterator(s)

    def folder(it: Iterator[Tuple[Key, Value]]):
        try:
            current = next(it)
        except StopIteration:
            return Nothing
        else:
            return Some((current, it))

    return pipe(it, seq.unfold(folder))</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.try_find"><code class="name flex">
<span>def <span class="ident">try_find</span></span>(<span>k: ~Key, m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_find(k: Key, m: MapTree[Key, Value]) -&gt; Option[Value]:
    for m2 in m.to_list():
        if k == m2.key:
            return Some(m2.value)
        else:
            if isinstance(m2, MapTreeNode):
                mn = cast(MapTreeNode[Key, Value], m2)
                return try_find(k, mn.left if k &lt; m2 else mn.right)
            else:
                return Nothing
    else:  # Nothing
        return Nothing</code></pre>
</details>
</dd>
<dt id="expression.collections.maptree.try_pick"><code class="name flex">
<span>def <span class="ident">try_pick</span></span>(<span>f: Callable[[~Key, ~Value], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Result]], m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Result]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_pick(f: Callable[[Key, Value], Option[Result]], m: MapTree[Key, Value]) -&gt; Option[Result]:
    for m2 in m.to_list():
        if isinstance(m2, MapTreeNode):
            mn = cast(MapTreeNode[Key, Value], m2)
            for res in try_pick(f, mn.left).to_list():
                return res
            else:
                for res in f(mn.key, mn.value):
                    return res
                else:
                    return try_pick(f, mn.right)
        else:
            return f(m2.key, m2.value)
    else:
        return Nothing</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="expression.collections.maptree.MapTreeLeaf"><code class="flex name class">
<span>class <span class="ident">MapTreeLeaf</span></span>
<span>(</span><span>key: ~Key, value: ~Value)</span>
</code></dt>
<dd>
<div class="desc"><p>MapTreeLeaf(<em>args, </em>*kwds)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MapTreeLeaf(Generic[Key, Value]):
    key: Key
    value: Value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="expression.collections.maptree.MapTreeNode" href="#expression.collections.maptree.MapTreeNode">MapTreeNode</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="expression.collections.maptree.MapTreeLeaf.key"><code class="name">var <span class="ident">key</span> : ~Key</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="expression.collections.maptree.MapTreeLeaf.value"><code class="name">var <span class="ident">value</span> : ~Value</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="expression.collections.maptree.MapTreeNode"><code class="flex name class">
<span>class <span class="ident">MapTreeNode</span></span>
<span>(</span><span>key: ~Key, value: ~Value, left: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], right: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]], height: int)</span>
</code></dt>
<dd>
<div class="desc"><p>MapTreeNode(<em>args, </em>*kwds)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MapTreeNode(MapTreeLeaf[Key, Value]):
    left: MapTree[Key, Value]
    right: MapTree[Key, Value]

    height: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="expression.collections.maptree.MapTreeNode.height"><code class="name">var <span class="ident">height</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="expression.collections.maptree.MapTreeNode.left"><code class="name">var <span class="ident">left</span> : <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="expression.collections.maptree.MapTreeNode.right"><code class="name">var <span class="ident">right</span> : <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="expression.collections.maptree.MkIterator"><code class="flex name class">
<span>class <span class="ident">MkIterator</span></span>
<span>(</span><span>m: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[<a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a>[~Key, ~Value]])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MkIterator(Iterator[Tuple[Key, Value]]):
    def __init__(self, m: MapTree[Key, Value]) -&gt; None:
        self.stack = collapseLHS(frozenlist.singleton(m))

    def __next__(self) -&gt; Tuple[Key, Value]:
        if not self.stack:
            raise StopIteration

        rest = self.stack.tail()
        for m in self.stack.head():
            if isinstance(m, MapTreeNode):
                failwith(&#34;Please report error: Map iterator, unexpected stack for next()&#34;)
            else:
                self.stack = collapseLHS(rest)
                return m.key, m.value
        else:
            failwith(&#34;Please report error: Map iterator, unexpected stack for next()&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Iterator</li>
<li>collections.abc.Iterable</li>
<li>typing.Generic</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="expression.collections" href="index.html">expression.collections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="expression.collections.maptree.add" href="#expression.collections.maptree.add">add</a></code></li>
<li><code><a title="expression.collections.maptree.already_finished" href="#expression.collections.maptree.already_finished">already_finished</a></code></li>
<li><code><a title="expression.collections.maptree.change" href="#expression.collections.maptree.change">change</a></code></li>
<li><code><a title="expression.collections.maptree.collapseLHS" href="#expression.collections.maptree.collapseLHS">collapseLHS</a></code></li>
<li><code><a title="expression.collections.maptree.exists" href="#expression.collections.maptree.exists">exists</a></code></li>
<li><code><a title="expression.collections.maptree.filter" href="#expression.collections.maptree.filter">filter</a></code></li>
<li><code><a title="expression.collections.maptree.filter1" href="#expression.collections.maptree.filter1">filter1</a></code></li>
<li><code><a title="expression.collections.maptree.filter_aux" href="#expression.collections.maptree.filter_aux">filter_aux</a></code></li>
<li><code><a title="expression.collections.maptree.find" href="#expression.collections.maptree.find">find</a></code></li>
<li><code><a title="expression.collections.maptree.fold" href="#expression.collections.maptree.fold">fold</a></code></li>
<li><code><a title="expression.collections.maptree.fold_back" href="#expression.collections.maptree.fold_back">fold_back</a></code></li>
<li><code><a title="expression.collections.maptree.forall" href="#expression.collections.maptree.forall">forall</a></code></li>
<li><code><a title="expression.collections.maptree.height" href="#expression.collections.maptree.height">height</a></code></li>
<li><code><a title="expression.collections.maptree.is_empty" href="#expression.collections.maptree.is_empty">is_empty</a></code></li>
<li><code><a title="expression.collections.maptree.iter" href="#expression.collections.maptree.iter">iter</a></code></li>
<li><code><a title="expression.collections.maptree.map" href="#expression.collections.maptree.map">map</a></code></li>
<li><code><a title="expression.collections.maptree.mapi" href="#expression.collections.maptree.mapi">mapi</a></code></li>
<li><code><a title="expression.collections.maptree.mem" href="#expression.collections.maptree.mem">mem</a></code></li>
<li><code><a title="expression.collections.maptree.mk" href="#expression.collections.maptree.mk">mk</a></code></li>
<li><code><a title="expression.collections.maptree.mk_from_iterator" href="#expression.collections.maptree.mk_from_iterator">mk_from_iterator</a></code></li>
<li><code><a title="expression.collections.maptree.mk_iterator" href="#expression.collections.maptree.mk_iterator">mk_iterator</a></code></li>
<li><code><a title="expression.collections.maptree.not_started" href="#expression.collections.maptree.not_started">not_started</a></code></li>
<li><code><a title="expression.collections.maptree.of_list" href="#expression.collections.maptree.of_list">of_list</a></code></li>
<li><code><a title="expression.collections.maptree.of_seq" href="#expression.collections.maptree.of_seq">of_seq</a></code></li>
<li><code><a title="expression.collections.maptree.partition" href="#expression.collections.maptree.partition">partition</a></code></li>
<li><code><a title="expression.collections.maptree.partition1" href="#expression.collections.maptree.partition1">partition1</a></code></li>
<li><code><a title="expression.collections.maptree.partition_aux" href="#expression.collections.maptree.partition_aux">partition_aux</a></code></li>
<li><code><a title="expression.collections.maptree.rebalance" href="#expression.collections.maptree.rebalance">rebalance</a></code></li>
<li><code><a title="expression.collections.maptree.remove" href="#expression.collections.maptree.remove">remove</a></code></li>
<li><code><a title="expression.collections.maptree.size" href="#expression.collections.maptree.size">size</a></code></li>
<li><code><a title="expression.collections.maptree.size_aux" href="#expression.collections.maptree.size_aux">size_aux</a></code></li>
<li><code><a title="expression.collections.maptree.splice_out_successor" href="#expression.collections.maptree.splice_out_successor">splice_out_successor</a></code></li>
<li><code><a title="expression.collections.maptree.to_list" href="#expression.collections.maptree.to_list">to_list</a></code></li>
<li><code><a title="expression.collections.maptree.to_seq" href="#expression.collections.maptree.to_seq">to_seq</a></code></li>
<li><code><a title="expression.collections.maptree.try_find" href="#expression.collections.maptree.try_find">try_find</a></code></li>
<li><code><a title="expression.collections.maptree.try_pick" href="#expression.collections.maptree.try_pick">try_pick</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="expression.collections.maptree.MapTreeLeaf" href="#expression.collections.maptree.MapTreeLeaf">MapTreeLeaf</a></code></h4>
<ul class="">
<li><code><a title="expression.collections.maptree.MapTreeLeaf.key" href="#expression.collections.maptree.MapTreeLeaf.key">key</a></code></li>
<li><code><a title="expression.collections.maptree.MapTreeLeaf.value" href="#expression.collections.maptree.MapTreeLeaf.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="expression.collections.maptree.MapTreeNode" href="#expression.collections.maptree.MapTreeNode">MapTreeNode</a></code></h4>
<ul class="">
<li><code><a title="expression.collections.maptree.MapTreeNode.height" href="#expression.collections.maptree.MapTreeNode.height">height</a></code></li>
<li><code><a title="expression.collections.maptree.MapTreeNode.left" href="#expression.collections.maptree.MapTreeNode.left">left</a></code></li>
<li><code><a title="expression.collections.maptree.MapTreeNode.right" href="#expression.collections.maptree.MapTreeNode.right">right</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="expression.collections.maptree.MkIterator" href="#expression.collections.maptree.MkIterator">MkIterator</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>