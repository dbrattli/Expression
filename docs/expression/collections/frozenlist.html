<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>expression.collections.frozenlist API documentation</title>
<meta name="description" content="A frozen immutable list module …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>expression.collections.frozenlist</code></h1>
</header>
<section id="section-intro">
<p>A frozen immutable list module.</p>
<p>This module provides an immutable list type <code><a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a></code> and
a set of
useful methods and functions for working with the list.</p>
<p>Named "FrozenList" to avoid conflicts with the builtin Python List type.</p>
<p>A FrozenList is actually a Python tuple. Tuples in Python are
immutable and gives us a high performant implementation of immutable
lists.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; xs = frozenlist.of_list([1, 2, 3, 4, 5])
&gt;&gt;&gt; ys = frozenlist.empty.cons(1).cons(2).cons(3).cons(4).cons(5)
&gt;&gt;&gt; zs = pipe(
...     xs,
...     frozenlist.filter(lambda x: x&lt;10)
... )
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A frozen immutable list module.

This module provides an immutable list type `FrozenList` and  a set of
useful methods and functions for working with the list.

Named &#34;FrozenList&#34; to avoid conflicts with the builtin Python List type.

A FrozenList is actually a Python tuple. Tuples in Python are
immutable and gives us a high performant implementation of immutable
lists.

Example:
    &gt;&gt;&gt; xs = frozenlist.of_list([1, 2, 3, 4, 5])
    &gt;&gt;&gt; ys = frozenlist.empty.cons(1).cons(2).cons(3).cons(4).cons(5)
    &gt;&gt;&gt; zs = pipe(
...     xs,
...     frozenlist.filter(lambda x: x&lt;10)
... )
&#34;&#34;&#34;

import builtins
import functools
from typing import Any, Callable, Iterable, Tuple, TypeVar, cast, overload

from expression.core.option import Nothing, Option, Some, pipe

from . import seq

TSource = TypeVar(&#34;TSource&#34;)
TResult = TypeVar(&#34;TResult&#34;)
TState = TypeVar(&#34;TState&#34;)
T1 = TypeVar(&#34;T1&#34;)
T2 = TypeVar(&#34;T2&#34;)
T3 = TypeVar(&#34;T3&#34;)
T4 = TypeVar(&#34;T4&#34;)
T5 = TypeVar(&#34;T5&#34;)
T6 = TypeVar(&#34;T6&#34;)


class FrozenList(Tuple[TSource]):
    &#34;&#34;&#34;Immutable list type.

    This is not the most space efficient implementation of a list. If
    that is the goal then use the builin mutable list or array types
    instead. Use this list if you need an immutable list for prepend
    operations mostly (`O(1)`).

    Example:
        &gt;&gt;&gt; xs = Cons(5, Cons(4, Cons(3, Cons(2, Cons(1, Nil)))))
        &gt;&gt;&gt; ys = empty.cons(1).cons(2).cons(3).cons(4).cons(5)
    &#34;&#34;&#34;

    def match(self, *args: Any, **kw: Any) -&gt; Any:
        from pampy import match  # type: ignore

        return match(self, *args, **kw)  # type: ignore

    @overload
    def pipe(self, __fn1: Callable[[&#34;FrozenList[TSource]&#34;], TResult]) -&gt; TResult:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(
        self, __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]
    ) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
    ) -&gt; T5:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
        __fn6: Callable[[T5], T6],
    ) -&gt; T6:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe list through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    def append(self, other: &#34;FrozenList[TSource]&#34;) -&gt; &#34;FrozenList[TSource]&#34;:
        return FrozenList(self + other)

    def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; &#34;FrozenList[TResult]&#34;:
        &#34;&#34;&#34;Choose items from the list.

        Applies the given function to each element of the list. Returns
        the list comprised of the results x for each element where the
        function returns `Some(x)`.

        Args:
            chooser: The function to generate options from the elements.

        Returns:
            The list comprising the values selected from the chooser
            function.
        &#34;&#34;&#34;

        def mapper(x: TSource) -&gt; FrozenList[TResult]:
            return FrozenList(chooser(x).to_seq())

        return self.collect(mapper)

    def collect(self, mapping: Callable[[TSource], &#34;FrozenList[TResult]&#34;]) -&gt; &#34;FrozenList[TResult]&#34;:
        mapped = builtins.map(mapping, self)
        xs = (y for x in mapped for y in x)
        return FrozenList(xs)

    def cons(self, element: TSource) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Add element to front of List.&#34;&#34;&#34;

        return FrozenList((element, *self))

    def filter(self, predicate: Callable[[TSource], bool]) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Filter list.

        Returns a new collection containing only the elements of the
        collection for which the given predicate returns `True`.

        Args:
            predicate: The function to test the input elements.

        Returns:
            A list containing only the elements that satisfy the
            predicate.
        &#34;&#34;&#34;
        return FrozenList(builtins.filter(predicate, self))

    def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
        &#34;&#34;&#34;Applies a function to each element of the collection,
        threading an accumulator argument through the computation. Take
        the second argument, and apply the function to it and the first
        element of the list. Then feed this result into the function
        along with the second element and so on. Return the final
        result. If the input function is f and the elements are i0...iN
        then computes f (... (f s i0) i1 ...) iN.

        Args:
            folder: The function to update the state given the input
                elements.

            state: The initial state.

        Returns:
            Partially applied fold function that takes the source list
            and returns the final state value.
        &#34;&#34;&#34;
        return functools.reduce(folder, self, state)

    def head(self) -&gt; TSource:
        &#34;&#34;&#34;Returns the first element of the list.

        Args:
            source: The input list.

        Returns:
            The first element of the list.

        Raises:
            ValueError: Thrown when the list is empty.
        &#34;&#34;&#34;

        head, *_ = self
        return head

    def indexed(self, start: int = 0) -&gt; &#34;FrozenList[Tuple[int, TSource]]&#34;:
        &#34;&#34;&#34;Returns a new list whose elements are the corresponding
        elements of the input list paired with the index (from `start`)
        of each element.

        Args:
            start: Optional index to start from. Defaults to 0.

        Returns:
            The list of indexed elements.
        &#34;&#34;&#34;
        return FrozenList(enumerate(self))

    def item(self, index: int) -&gt; TSource:
        &#34;&#34;&#34;Indexes into the list. The first element has index 0.

        Args:
            index: The index to retrieve.

        Returns:
            The value at the given index.
        &#34;&#34;&#34;
        return self[index]

    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;Return `True` if list is empty.&#34;&#34;&#34;

        return not bool(self)

    def map(self, mapping: Callable[[TSource], TResult]) -&gt; &#34;FrozenList[TResult]&#34;:
        &#34;&#34;&#34;Map list.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection.

        Args:
            mapping: The function to transform elements from the input
                list.

        Returns:
            The list of transformed elements.
        &#34;&#34;&#34;
        return FrozenList((*builtins.map(mapping, self),))

    def skip(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Returns the list after removing the first N elements.

        Args:
            count: The number of elements to skip.

        Returns:
            The list after removing the first N elements.
        &#34;&#34;&#34;
        return FrozenList(self[count:])

    def skip_last(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
        return FrozenList(self[:-count])

    def tail(self) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Return tail of List.&#34;&#34;&#34;

        _, *tail = self
        return FrozenList(tail)

    def take(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Returns the first N elements of the list.

        Args:
            count: The number of items to take.

        Returns:
            The result list.
        &#34;&#34;&#34;
        return FrozenList(self[:count])

    def take_last(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Returns a specified number of contiguous elements from the
        end of the list.

        Args:
            count: The number of items to take.

        Returns:
            The result list.
        &#34;&#34;&#34;
        return FrozenList(self[-count:])

    def try_head(self) -&gt; Option[TSource]:
        &#34;&#34;&#34;Returns the first element of the list, or None if the list is
        empty.
        &#34;&#34;&#34;
        return Some(self[0]) if self else Nothing

    @staticmethod
    def unfold(generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Returns a list that contains the elements generated by the
        given computation. The given initial state argument is passed to
        the element generator.

        Args:
            generator: A function that takes in the current state and
                returns an option tuple of the next element of the list
                and the next state value.
            state: The initial state.

        Returns:
            The result list.
        &#34;&#34;&#34;

        result: Option[Tuple[TSource, TState]] = generator(state)
        for (item, state_) in result.to_list():
            return FrozenList.unfold(generator, state_).cons(item)
        else:
            return empty

    def zip(self, other: &#34;FrozenList[TResult]&#34;) -&gt; &#34;FrozenList[Tuple[TSource, TResult]]&#34;:
        &#34;&#34;&#34;Combines the two lists into a list of pairs. The two lists
        must have equal lengths. .

        Args:
            other: The second input list.

        Returns:
            A single list containing pairs of matching elements from the
            input lists.
        &#34;&#34;&#34;
        return FrozenList(builtins.zip(self, other))

    def __str__(self) -&gt; str:
        return f&#34;[{&#39;, &#39;.join(self.map(str))}]&#34;

    def __repr__(self) -&gt; str:
        return str(self)


def append(source: FrozenList[TSource]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    def _append(other: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.append(other)

    return _append


def choose(chooser: Callable[[TSource], Option[TResult]]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TResult]]:
    def _choose(source: FrozenList[TSource]) -&gt; FrozenList[TResult]:
        return source.choose(chooser)

    return _choose


def collect(mapping: Callable[[TSource], FrozenList[TResult]]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TResult]]:
    &#34;&#34;&#34;For each element of the list, applies the given function.
    Concatenates all the results and return the combined list.

    Args:
        mapping: he function to transform each input element into
        a sublist to be concatenated.

    Returns:
        A partially applied collect function that takes the source
        list and returns the concatenation of the transformed sublists.
    &#34;&#34;&#34;

    def _collect(source: FrozenList[TSource]) -&gt; FrozenList[TResult]:
        &#34;&#34;&#34;For each element of the list, applies the given function.
        Concatenates all the results and return the combined list.

        Args:
            source: The input list.

        Returns:
            The concatenation of the transformed sublists.
        &#34;&#34;&#34;
        return source.collect(mapping)

    return _collect


def concat(sources: Iterable[FrozenList[TSource]]) -&gt; FrozenList[TSource]:
    def reducer(t: FrozenList[TSource], s: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return t.append(s)

    return pipe(sources, seq.fold(reducer, empty))


def cons(head: TSource, tail: FrozenList[TSource]) -&gt; FrozenList[TSource]:
    return FrozenList(head, *tail)


nil: FrozenList[Any] = FrozenList()
empty: FrozenList[Any] = nil
&#34;&#34;&#34;The empty list.&#34;&#34;&#34;


def filter(predicate: Callable[[TSource], bool]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns a new collection containing only the elements of the
    collection for which the given predicate returns `True`

    Args:
        predicate: The function to test the input elements.

    Returns:
        Partially applied filter function.
    &#34;&#34;&#34;

    def _filter(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Returns a new collection containing only the elements of the
        collection for which the given predicate returns `True`

        Args:
            source: The input list..

        Returns:
            A list containing only the elements that satisfy the predicate.
        &#34;&#34;&#34;
        return source.filter(predicate)

    return _filter


def fold(folder: Callable[[TState, TSource], TState], state: TState) -&gt; Callable[[FrozenList[TSource]], TState]:
    &#34;&#34;&#34;Applies a function to each element of the collection, threading
    an accumulator argument through the computation. Take the second
    argument, and apply the function to it and the first element of the
    list. Then feed this result into the function along with the second
    element and so on. Return the final result. If the input function is
    f and the elements are i0...iN then computes f (... (f s i0) i1 ...)
    iN.

    Args:
        folder: The function to update the state given the input elements.

        state: The initial state.

    Returns:
        Partially applied fold function that takes the source list
        and returns the final state value.
    &#34;&#34;&#34;

    def _fold(source: FrozenList[TSource]) -&gt; TState:
        return source.fold(folder, state)

    return _fold


def head(source: FrozenList[TSource]) -&gt; TSource:
    &#34;&#34;&#34;Returns the first element of the list.

    Args:
        source: The input list.

    Returns:
        The first element of the list.

    Raises:
         ValueError: Thrown when the list is empty.
    &#34;&#34;&#34;
    return source.head()


def indexed(source: FrozenList[TSource]) -&gt; FrozenList[Tuple[int, TSource]]:
    &#34;&#34;&#34;Returns a new list whose elements are the corresponding
    elements of the input list paired with the index (from 0)
    of each element.

    Returns:
        The list of indexed elements.
    &#34;&#34;&#34;
    return source.indexed()


def item(index: int) -&gt; Callable[[FrozenList[TSource]], TSource]:
    &#34;&#34;&#34;Indexes into the list. The first element has index 0.

    Args:
        index: The index to retrieve.

    Returns:
        The value at the given index.
    &#34;&#34;&#34;

    def _(source: FrozenList[TSource]) -&gt; TSource:
        return source.item(index)

    return _


def is_empty(source: FrozenList[TSource]) -&gt; bool:
    &#34;&#34;&#34;Returns `True` if the list is empty, `False` otherwise.&#34;&#34;&#34;
    return source.is_empty()


def map(mapper: Callable[[TSource], TResult]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TResult]]:
    &#34;&#34;&#34;Map list.

    Builds a new collection whose elements are the results of applying
    the given function to each of the elements of the collection.

    Args:
        mapper: The function to transform elements from the input list.

    Returns:
        The list of transformed elements.
    &#34;&#34;&#34;

    def _map(source: FrozenList[TSource]) -&gt; FrozenList[TResult]:
        return source.map(mapper)

    return _map


def of_seq(xs: Iterable[TSource]) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Create list from iterable sequence.&#34;&#34;&#34;
    return FrozenList((*xs,))


def of_option(option: Option[TSource]) -&gt; FrozenList[TSource]:
    if isinstance(option, Some):
        return singleton(cast(Some[TSource], option).value)
    return empty


def singleton(value: TSource) -&gt; FrozenList[TSource]:
    return FrozenList((value,))


def skip(count: int) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns the list after removing the first N elements.

    Args:
        count: The number of elements to skip.
    Returns:
        The list after removing the first N elements.
    &#34;&#34;&#34;

    def _skip(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.skip(count)

    return _skip


def skip_last(count: int) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns the list after removing the last N elements.

    Args:
        count: The number of elements to skip.
    Returns:
        The list after removing the last N elements.
    &#34;&#34;&#34;

    def _skip_last(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.skip_last(count)

    return _skip_last


def tail(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
    return source.tail()


def take(count: int) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns the first N elements of the list.

    Args:
        count: The number of items to take.

    Returns:
        The result list.
    &#34;&#34;&#34;

    def _take(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.take(count)

    return _take


def take_last(count: int) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns a specified number of contiguous elements from the end of
    the list.

    Args:
        count: The number of items to take.

    Returns:
        The result list.
    &#34;&#34;&#34;

    def _take(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.take_last(count)

    return _take


def try_head(source: FrozenList[TSource]) -&gt; Option[TSource]:
    &#34;&#34;&#34;Try to get the first element from the list.

    Returns the first element of the list, or None if the list is empty.

    Args:
        source: The input list.

    Returns:
        The first element of the list or `Nothing`.
    &#34;&#34;&#34;
    return source.try_head()


def unfold(generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; &#34;FrozenList[TSource]&#34;:
    &#34;&#34;&#34;Returns a list that contains the elements generated by the
    given computation. The given initial state argument is passed to
    the element generator.

    Args:
        generator: A function that takes in the current state and
            returns an option tuple of the next element of the list
            and the next state value.
        state: The initial state.

    Returns:
        The result list.
    &#34;&#34;&#34;

    return FrozenList.unfold(generator, state)


def zip(other: FrozenList[TResult]) -&gt; Callable[[FrozenList[TSource]], FrozenList[Tuple[TSource, TResult]]]:
    &#34;&#34;&#34;Combines the two lists into a list of pairs. The two lists
    must have equal lengths.

    Args:
        other: The second input list.

    Returns:
        Paritally applied zip function that takes the source list and
        returns s single list containing pairs of matching elements from
        the input lists.
    &#34;&#34;&#34;

    def _zip(source: FrozenList[TSource]) -&gt; FrozenList[Tuple[TSource, TResult]]:
        &#34;&#34;&#34;Combines the two lists into a list of pairs. The two lists
        must have equal lengths.

        Args:
            source: The source input list.

        Returns:
            A single list containing pairs of matching elements from the
            input lists.
        &#34;&#34;&#34;
        return source.zip(other)

    return _zip


__all__ = [
    &#34;FrozenList&#34;,
    &#34;append&#34;,
    &#34;choose&#34;,
    &#34;collect&#34;,
    &#34;concat&#34;,
    &#34;empty&#34;,
    &#34;filter&#34;,
    &#34;fold&#34;,
    &#34;head&#34;,
    &#34;indexed&#34;,
    &#34;item&#34;,
    &#34;is_empty&#34;,
    &#34;map&#34;,
    &#34;of_seq&#34;,
    &#34;of_option&#34;,
    &#34;singleton&#34;,
    &#34;skip&#34;,
    &#34;skip_last&#34;,
    &#34;tail&#34;,
    &#34;take&#34;,
    &#34;take_last&#34;,
    &#34;try_head&#34;,
    &#34;unfold&#34;,
    &#34;zip&#34;,
]</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="expression.collections.frozenlist.empty"><code class="name">var <span class="ident">empty</span> : <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Any]</code></dt>
<dd>
<div class="desc"><p>The empty list.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="expression.collections.frozenlist.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>source: <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(source: FrozenList[TSource]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    def _append(other: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.append(other)

    return _append</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.choose"><code class="name flex">
<span>def <span class="ident">choose</span></span>(<span>chooser: Callable[[~TSource], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~TResult]]) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose(chooser: Callable[[TSource], Option[TResult]]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TResult]]:
    def _choose(source: FrozenList[TSource]) -&gt; FrozenList[TResult]:
        return source.choose(chooser)

    return _choose</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.collect"><code class="name flex">
<span>def <span class="ident">collect</span></span>(<span>mapping: Callable[[~TSource], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]]) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]]</span>
</code></dt>
<dd>
<div class="desc"><p>For each element of the list, applies the given function.
Concatenates all the results and return the combined list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>he function to transform each input element into</dd>
</dl>
<p>a sublist to be concatenated.</p>
<h2 id="returns">Returns</h2>
<p>A partially applied collect function that takes the source
list and returns the concatenation of the transformed sublists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect(mapping: Callable[[TSource], FrozenList[TResult]]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TResult]]:
    &#34;&#34;&#34;For each element of the list, applies the given function.
    Concatenates all the results and return the combined list.

    Args:
        mapping: he function to transform each input element into
        a sublist to be concatenated.

    Returns:
        A partially applied collect function that takes the source
        list and returns the concatenation of the transformed sublists.
    &#34;&#34;&#34;

    def _collect(source: FrozenList[TSource]) -&gt; FrozenList[TResult]:
        &#34;&#34;&#34;For each element of the list, applies the given function.
        Concatenates all the results and return the combined list.

        Args:
            source: The input list.

        Returns:
            The concatenation of the transformed sublists.
        &#34;&#34;&#34;
        return source.collect(mapping)

    return _collect</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>sources: Iterable[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(sources: Iterable[FrozenList[TSource]]) -&gt; FrozenList[TSource]:
    def reducer(t: FrozenList[TSource], s: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return t.append(s)

    return pipe(sources, seq.fold(reducer, empty))</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>predicate: Callable[[~TSource], bool]) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new collection containing only the elements of the
collection for which the given predicate returns <code>True</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>The function to test the input elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied filter function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(predicate: Callable[[TSource], bool]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns a new collection containing only the elements of the
    collection for which the given predicate returns `True`

    Args:
        predicate: The function to test the input elements.

    Returns:
        Partially applied filter function.
    &#34;&#34;&#34;

    def _filter(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        &#34;&#34;&#34;Returns a new collection containing only the elements of the
        collection for which the given predicate returns `True`

        Args:
            source: The input list..

        Returns:
            A list containing only the elements that satisfy the predicate.
        &#34;&#34;&#34;
        return source.filter(predicate)

    return _filter</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>folder: Callable[[~TState, ~TSource], ~TState], state: ~TState) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], ~TState]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a function to each element of the collection, threading
an accumulator argument through the computation. Take the second
argument, and apply the function to it and the first element of the
list. Then feed this result into the function along with the second
element and so on. Return the final result. If the input function is
f and the elements are i0&hellip;iN then computes f (&hellip; (f s i0) i1 &hellip;)
iN.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder</code></strong></dt>
<dd>The function to update the state given the input elements.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied fold function that takes the source list
and returns the final state value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(folder: Callable[[TState, TSource], TState], state: TState) -&gt; Callable[[FrozenList[TSource]], TState]:
    &#34;&#34;&#34;Applies a function to each element of the collection, threading
    an accumulator argument through the computation. Take the second
    argument, and apply the function to it and the first element of the
    list. Then feed this result into the function along with the second
    element and so on. Return the final result. If the input function is
    f and the elements are i0...iN then computes f (... (f s i0) i1 ...)
    iN.

    Args:
        folder: The function to update the state given the input elements.

        state: The initial state.

    Returns:
        Partially applied fold function that takes the source list
        and returns the final state value.
    &#34;&#34;&#34;

    def _fold(source: FrozenList[TSource]) -&gt; TState:
        return source.fold(folder, state)

    return _fold</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>source: <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]) ‑> ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first element of the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>The input list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The first element of the list.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Thrown when the list is empty.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(source: FrozenList[TSource]) -&gt; TSource:
    &#34;&#34;&#34;Returns the first element of the list.

    Args:
        source: The input list.

    Returns:
        The first element of the list.

    Raises:
         ValueError: Thrown when the list is empty.
    &#34;&#34;&#34;
    return source.head()</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.indexed"><code class="name flex">
<span>def <span class="ident">indexed</span></span>(<span>source: <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[int, ~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new list whose elements are the corresponding
elements of the input list paired with the index (from 0)
of each element.</p>
<h2 id="returns">Returns</h2>
<p>The list of indexed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indexed(source: FrozenList[TSource]) -&gt; FrozenList[Tuple[int, TSource]]:
    &#34;&#34;&#34;Returns a new list whose elements are the corresponding
    elements of the input list paired with the index (from 0)
    of each element.

    Returns:
        The list of indexed elements.
    &#34;&#34;&#34;
    return source.indexed()</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>source: <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> if the list is empty, <code>False</code> otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(source: FrozenList[TSource]) -&gt; bool:
    &#34;&#34;&#34;Returns `True` if the list is empty, `False` otherwise.&#34;&#34;&#34;
    return source.is_empty()</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>index: int) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], ~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Indexes into the list. The first element has index 0.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>The index to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The value at the given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item(index: int) -&gt; Callable[[FrozenList[TSource]], TSource]:
    &#34;&#34;&#34;Indexes into the list. The first element has index 0.

    Args:
        index: The index to retrieve.

    Returns:
        The value at the given index.
    &#34;&#34;&#34;

    def _(source: FrozenList[TSource]) -&gt; TSource:
        return source.item(index)

    return _</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>mapper: Callable[[~TSource], ~TResult]) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]]</span>
</code></dt>
<dd>
<div class="desc"><p>Map list.</p>
<p>Builds a new collection whose elements are the results of applying
the given function to each of the elements of the collection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapper</code></strong></dt>
<dd>The function to transform elements from the input list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list of transformed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(mapper: Callable[[TSource], TResult]) -&gt; Callable[[FrozenList[TSource]], FrozenList[TResult]]:
    &#34;&#34;&#34;Map list.

    Builds a new collection whose elements are the results of applying
    the given function to each of the elements of the collection.

    Args:
        mapper: The function to transform elements from the input list.

    Returns:
        The list of transformed elements.
    &#34;&#34;&#34;

    def _map(source: FrozenList[TSource]) -&gt; FrozenList[TResult]:
        return source.map(mapper)

    return _map</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.of_option"><code class="name flex">
<span>def <span class="ident">of_option</span></span>(<span>option: <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~TSource]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_option(option: Option[TSource]) -&gt; FrozenList[TSource]:
    if isinstance(option, Some):
        return singleton(cast(Some[TSource], option).value)
    return empty</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.of_seq"><code class="name flex">
<span>def <span class="ident">of_seq</span></span>(<span>xs: Iterable[~TSource]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Create list from iterable sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_seq(xs: Iterable[TSource]) -&gt; FrozenList[TSource]:
    &#34;&#34;&#34;Create list from iterable sequence.&#34;&#34;&#34;
    return FrozenList((*xs,))</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.singleton"><code class="name flex">
<span>def <span class="ident">singleton</span></span>(<span>value: ~TSource) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def singleton(value: TSource) -&gt; FrozenList[TSource]:
    return FrozenList((value,))</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>count: int) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list after removing the first N elements.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of elements to skip.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list after removing the first N elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(count: int) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns the list after removing the first N elements.

    Args:
        count: The number of elements to skip.
    Returns:
        The list after removing the first N elements.
    &#34;&#34;&#34;

    def _skip(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.skip(count)

    return _skip</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.skip_last"><code class="name flex">
<span>def <span class="ident">skip_last</span></span>(<span>count: int) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list after removing the last N elements.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of elements to skip.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list after removing the last N elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip_last(count: int) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns the list after removing the last N elements.

    Args:
        count: The number of elements to skip.
    Returns:
        The list after removing the last N elements.
    &#34;&#34;&#34;

    def _skip_last(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.skip_last(count)

    return _skip_last</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>source: <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
    return source.tail()</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>count: int) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first N elements of the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to take.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(count: int) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns the first N elements of the list.

    Args:
        count: The number of items to take.

    Returns:
        The result list.
    &#34;&#34;&#34;

    def _take(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.take(count)

    return _take</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.take_last"><code class="name flex">
<span>def <span class="ident">take_last</span></span>(<span>count: int) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a specified number of contiguous elements from the end of
the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to take.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_last(count: int) -&gt; Callable[[FrozenList[TSource]], FrozenList[TSource]]:
    &#34;&#34;&#34;Returns a specified number of contiguous elements from the end of
    the list.

    Args:
        count: The number of items to take.

    Returns:
        The result list.
    &#34;&#34;&#34;

    def _take(source: FrozenList[TSource]) -&gt; FrozenList[TSource]:
        return source.take_last(count)

    return _take</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.try_head"><code class="name flex">
<span>def <span class="ident">try_head</span></span>(<span>source: <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Try to get the first element from the list.</p>
<p>Returns the first element of the list, or None if the list is empty.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>The input list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The first element of the list or <code>Nothing</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_head(source: FrozenList[TSource]) -&gt; Option[TSource]:
    &#34;&#34;&#34;Try to get the first element from the list.

    Returns the first element of the list, or None if the list is empty.

    Args:
        source: The input list.

    Returns:
        The first element of the list or `Nothing`.
    &#34;&#34;&#34;
    return source.try_head()</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.unfold"><code class="name flex">
<span>def <span class="ident">unfold</span></span>(<span>generator: Callable[[~TState], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[Tuple[~TSource, ~TState]]], state: ~TState) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list that contains the elements generated by the
given computation. The given initial state argument is passed to
the element generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>A function that takes in the current state and
returns an option tuple of the next element of the list
and the next state value.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unfold(generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; &#34;FrozenList[TSource]&#34;:
    &#34;&#34;&#34;Returns a list that contains the elements generated by the
    given computation. The given initial state argument is passed to
    the element generator.

    Args:
        generator: A function that takes in the current state and
            returns an option tuple of the next element of the list
            and the next state value.
        state: The initial state.

    Returns:
        The result list.
    &#34;&#34;&#34;

    return FrozenList.unfold(generator, state)</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>other: <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]) ‑> Callable[[<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]], <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[Tuple[~TSource, ~TResult]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Combines the two lists into a list of pairs. The two lists
must have equal lengths.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>The second input list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Paritally applied zip function that takes the source list and
returns s single list containing pairs of matching elements from
the input lists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(other: FrozenList[TResult]) -&gt; Callable[[FrozenList[TSource]], FrozenList[Tuple[TSource, TResult]]]:
    &#34;&#34;&#34;Combines the two lists into a list of pairs. The two lists
    must have equal lengths.

    Args:
        other: The second input list.

    Returns:
        Paritally applied zip function that takes the source list and
        returns s single list containing pairs of matching elements from
        the input lists.
    &#34;&#34;&#34;

    def _zip(source: FrozenList[TSource]) -&gt; FrozenList[Tuple[TSource, TResult]]:
        &#34;&#34;&#34;Combines the two lists into a list of pairs. The two lists
        must have equal lengths.

        Args:
            source: The source input list.

        Returns:
            A single list containing pairs of matching elements from the
            input lists.
        &#34;&#34;&#34;
        return source.zip(other)

    return _zip</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="expression.collections.frozenlist.FrozenList"><code class="flex name class">
<span>class <span class="ident">FrozenList</span></span>
<span>(</span><span>iterable=(), /)</span>
</code></dt>
<dd>
<div class="desc"><p>Immutable list type.</p>
<p>This is not the most space efficient implementation of a list. If
that is the goal then use the builin mutable list or array types
instead. Use this list if you need an immutable list for prepend
operations mostly (<code>O(1)</code>).</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; xs = Cons(5, Cons(4, Cons(3, Cons(2, Cons(1, Nil)))))
&gt;&gt;&gt; ys = empty.cons(1).cons(2).cons(3).cons(4).cons(5)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrozenList(Tuple[TSource]):
    &#34;&#34;&#34;Immutable list type.

    This is not the most space efficient implementation of a list. If
    that is the goal then use the builin mutable list or array types
    instead. Use this list if you need an immutable list for prepend
    operations mostly (`O(1)`).

    Example:
        &gt;&gt;&gt; xs = Cons(5, Cons(4, Cons(3, Cons(2, Cons(1, Nil)))))
        &gt;&gt;&gt; ys = empty.cons(1).cons(2).cons(3).cons(4).cons(5)
    &#34;&#34;&#34;

    def match(self, *args: Any, **kw: Any) -&gt; Any:
        from pampy import match  # type: ignore

        return match(self, *args, **kw)  # type: ignore

    @overload
    def pipe(self, __fn1: Callable[[&#34;FrozenList[TSource]&#34;], TResult]) -&gt; TResult:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(
        self, __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]
    ) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
    ) -&gt; T5:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;FrozenList[TSource]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
        __fn6: Callable[[T5], T6],
    ) -&gt; T6:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe list through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    def append(self, other: &#34;FrozenList[TSource]&#34;) -&gt; &#34;FrozenList[TSource]&#34;:
        return FrozenList(self + other)

    def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; &#34;FrozenList[TResult]&#34;:
        &#34;&#34;&#34;Choose items from the list.

        Applies the given function to each element of the list. Returns
        the list comprised of the results x for each element where the
        function returns `Some(x)`.

        Args:
            chooser: The function to generate options from the elements.

        Returns:
            The list comprising the values selected from the chooser
            function.
        &#34;&#34;&#34;

        def mapper(x: TSource) -&gt; FrozenList[TResult]:
            return FrozenList(chooser(x).to_seq())

        return self.collect(mapper)

    def collect(self, mapping: Callable[[TSource], &#34;FrozenList[TResult]&#34;]) -&gt; &#34;FrozenList[TResult]&#34;:
        mapped = builtins.map(mapping, self)
        xs = (y for x in mapped for y in x)
        return FrozenList(xs)

    def cons(self, element: TSource) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Add element to front of List.&#34;&#34;&#34;

        return FrozenList((element, *self))

    def filter(self, predicate: Callable[[TSource], bool]) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Filter list.

        Returns a new collection containing only the elements of the
        collection for which the given predicate returns `True`.

        Args:
            predicate: The function to test the input elements.

        Returns:
            A list containing only the elements that satisfy the
            predicate.
        &#34;&#34;&#34;
        return FrozenList(builtins.filter(predicate, self))

    def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
        &#34;&#34;&#34;Applies a function to each element of the collection,
        threading an accumulator argument through the computation. Take
        the second argument, and apply the function to it and the first
        element of the list. Then feed this result into the function
        along with the second element and so on. Return the final
        result. If the input function is f and the elements are i0...iN
        then computes f (... (f s i0) i1 ...) iN.

        Args:
            folder: The function to update the state given the input
                elements.

            state: The initial state.

        Returns:
            Partially applied fold function that takes the source list
            and returns the final state value.
        &#34;&#34;&#34;
        return functools.reduce(folder, self, state)

    def head(self) -&gt; TSource:
        &#34;&#34;&#34;Returns the first element of the list.

        Args:
            source: The input list.

        Returns:
            The first element of the list.

        Raises:
            ValueError: Thrown when the list is empty.
        &#34;&#34;&#34;

        head, *_ = self
        return head

    def indexed(self, start: int = 0) -&gt; &#34;FrozenList[Tuple[int, TSource]]&#34;:
        &#34;&#34;&#34;Returns a new list whose elements are the corresponding
        elements of the input list paired with the index (from `start`)
        of each element.

        Args:
            start: Optional index to start from. Defaults to 0.

        Returns:
            The list of indexed elements.
        &#34;&#34;&#34;
        return FrozenList(enumerate(self))

    def item(self, index: int) -&gt; TSource:
        &#34;&#34;&#34;Indexes into the list. The first element has index 0.

        Args:
            index: The index to retrieve.

        Returns:
            The value at the given index.
        &#34;&#34;&#34;
        return self[index]

    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;Return `True` if list is empty.&#34;&#34;&#34;

        return not bool(self)

    def map(self, mapping: Callable[[TSource], TResult]) -&gt; &#34;FrozenList[TResult]&#34;:
        &#34;&#34;&#34;Map list.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection.

        Args:
            mapping: The function to transform elements from the input
                list.

        Returns:
            The list of transformed elements.
        &#34;&#34;&#34;
        return FrozenList((*builtins.map(mapping, self),))

    def skip(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Returns the list after removing the first N elements.

        Args:
            count: The number of elements to skip.

        Returns:
            The list after removing the first N elements.
        &#34;&#34;&#34;
        return FrozenList(self[count:])

    def skip_last(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
        return FrozenList(self[:-count])

    def tail(self) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Return tail of List.&#34;&#34;&#34;

        _, *tail = self
        return FrozenList(tail)

    def take(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Returns the first N elements of the list.

        Args:
            count: The number of items to take.

        Returns:
            The result list.
        &#34;&#34;&#34;
        return FrozenList(self[:count])

    def take_last(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Returns a specified number of contiguous elements from the
        end of the list.

        Args:
            count: The number of items to take.

        Returns:
            The result list.
        &#34;&#34;&#34;
        return FrozenList(self[-count:])

    def try_head(self) -&gt; Option[TSource]:
        &#34;&#34;&#34;Returns the first element of the list, or None if the list is
        empty.
        &#34;&#34;&#34;
        return Some(self[0]) if self else Nothing

    @staticmethod
    def unfold(generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; &#34;FrozenList[TSource]&#34;:
        &#34;&#34;&#34;Returns a list that contains the elements generated by the
        given computation. The given initial state argument is passed to
        the element generator.

        Args:
            generator: A function that takes in the current state and
                returns an option tuple of the next element of the list
                and the next state value.
            state: The initial state.

        Returns:
            The result list.
        &#34;&#34;&#34;

        result: Option[Tuple[TSource, TState]] = generator(state)
        for (item, state_) in result.to_list():
            return FrozenList.unfold(generator, state_).cons(item)
        else:
            return empty

    def zip(self, other: &#34;FrozenList[TResult]&#34;) -&gt; &#34;FrozenList[Tuple[TSource, TResult]]&#34;:
        &#34;&#34;&#34;Combines the two lists into a list of pairs. The two lists
        must have equal lengths. .

        Args:
            other: The second input list.

        Returns:
            A single list containing pairs of matching elements from the
            input lists.
        &#34;&#34;&#34;
        return FrozenList(builtins.zip(self, other))

    def __str__(self) -&gt; str:
        return f&#34;[{&#39;, &#39;.join(self.map(str))}]&#34;

    def __repr__(self) -&gt; str:
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="expression.collections.frozenlist.FrozenList.unfold"><code class="name flex">
<span>def <span class="ident">unfold</span></span>(<span>generator: Callable[[~TState], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[Tuple[~TSource, ~TState]]], state: ~TState) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list that contains the elements generated by the
given computation. The given initial state argument is passed to
the element generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>A function that takes in the current state and
returns an option tuple of the next element of the list
and the next state value.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unfold(generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; &#34;FrozenList[TSource]&#34;:
    &#34;&#34;&#34;Returns a list that contains the elements generated by the
    given computation. The given initial state argument is passed to
    the element generator.

    Args:
        generator: A function that takes in the current state and
            returns an option tuple of the next element of the list
            and the next state value.
        state: The initial state.

    Returns:
        The result list.
    &#34;&#34;&#34;

    result: Option[Tuple[TSource, TState]] = generator(state)
    for (item, state_) in result.to_list():
        return FrozenList.unfold(generator, state_).cons(item)
    else:
        return empty</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="expression.collections.frozenlist.FrozenList.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, other: <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[TSource]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, other: &#34;FrozenList[TSource]&#34;) -&gt; &#34;FrozenList[TSource]&#34;:
    return FrozenList(self + other)</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.choose"><code class="name flex">
<span>def <span class="ident">choose</span></span>(<span>self, chooser: Callable[[~TSource], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~TResult]]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]</span>
</code></dt>
<dd>
<div class="desc"><p>Choose items from the list.</p>
<p>Applies the given function to each element of the list. Returns
the list comprised of the results x for each element where the
function returns <code>Some(x)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chooser</code></strong></dt>
<dd>The function to generate options from the elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list comprising the values selected from the chooser
function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; &#34;FrozenList[TResult]&#34;:
    &#34;&#34;&#34;Choose items from the list.

    Applies the given function to each element of the list. Returns
    the list comprised of the results x for each element where the
    function returns `Some(x)`.

    Args:
        chooser: The function to generate options from the elements.

    Returns:
        The list comprising the values selected from the chooser
        function.
    &#34;&#34;&#34;

    def mapper(x: TSource) -&gt; FrozenList[TResult]:
        return FrozenList(chooser(x).to_seq())

    return self.collect(mapper)</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.collect"><code class="name flex">
<span>def <span class="ident">collect</span></span>(<span>self, mapping: Callable[[~TSource], ForwardRef('<a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[TResult]')]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect(self, mapping: Callable[[TSource], &#34;FrozenList[TResult]&#34;]) -&gt; &#34;FrozenList[TResult]&#34;:
    mapped = builtins.map(mapping, self)
    xs = (y for x in mapped for y in x)
    return FrozenList(xs)</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.cons"><code class="name flex">
<span>def <span class="ident">cons</span></span>(<span>self, element: ~TSource) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Add element to front of List.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cons(self, element: TSource) -&gt; &#34;FrozenList[TSource]&#34;:
    &#34;&#34;&#34;Add element to front of List.&#34;&#34;&#34;

    return FrozenList((element, *self))</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, predicate: Callable[[~TSource], bool]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Filter list.</p>
<p>Returns a new collection containing only the elements of the
collection for which the given predicate returns <code>True</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>The function to test the input elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list containing only the elements that satisfy the
predicate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, predicate: Callable[[TSource], bool]) -&gt; &#34;FrozenList[TSource]&#34;:
    &#34;&#34;&#34;Filter list.

    Returns a new collection containing only the elements of the
    collection for which the given predicate returns `True`.

    Args:
        predicate: The function to test the input elements.

    Returns:
        A list containing only the elements that satisfy the
        predicate.
    &#34;&#34;&#34;
    return FrozenList(builtins.filter(predicate, self))</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, folder: Callable[[~TState, ~TSource], ~TState], state: ~TState) ‑> ~TState</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a function to each element of the collection,
threading an accumulator argument through the computation. Take
the second argument, and apply the function to it and the first
element of the list. Then feed this result into the function
along with the second element and so on. Return the final
result. If the input function is f and the elements are i0&hellip;iN
then computes f (&hellip; (f s i0) i1 &hellip;) iN.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder</code></strong></dt>
<dd>The function to update the state given the input
elements.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied fold function that takes the source list
and returns the final state value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
    &#34;&#34;&#34;Applies a function to each element of the collection,
    threading an accumulator argument through the computation. Take
    the second argument, and apply the function to it and the first
    element of the list. Then feed this result into the function
    along with the second element and so on. Return the final
    result. If the input function is f and the elements are i0...iN
    then computes f (... (f s i0) i1 ...) iN.

    Args:
        folder: The function to update the state given the input
            elements.

        state: The initial state.

    Returns:
        Partially applied fold function that takes the source list
        and returns the final state value.
    &#34;&#34;&#34;
    return functools.reduce(folder, self, state)</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self) ‑> ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first element of the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>The input list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The first element of the list.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Thrown when the list is empty.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self) -&gt; TSource:
    &#34;&#34;&#34;Returns the first element of the list.

    Args:
        source: The input list.

    Returns:
        The first element of the list.

    Raises:
        ValueError: Thrown when the list is empty.
    &#34;&#34;&#34;

    head, *_ = self
    return head</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.indexed"><code class="name flex">
<span>def <span class="ident">indexed</span></span>(<span>self, start: int = 0) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[int, ~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new list whose elements are the corresponding
elements of the input list paired with the index (from <code>start</code>)
of each element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>Optional index to start from. Defaults to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list of indexed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indexed(self, start: int = 0) -&gt; &#34;FrozenList[Tuple[int, TSource]]&#34;:
    &#34;&#34;&#34;Returns a new list whose elements are the corresponding
    elements of the input list paired with the index (from `start`)
    of each element.

    Args:
        start: Optional index to start from. Defaults to 0.

    Returns:
        The list of indexed elements.
    &#34;&#34;&#34;
    return FrozenList(enumerate(self))</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if list is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self) -&gt; bool:
    &#34;&#34;&#34;Return `True` if list is empty.&#34;&#34;&#34;

    return not bool(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>self, index: int) ‑> ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Indexes into the list. The first element has index 0.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>The index to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The value at the given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item(self, index: int) -&gt; TSource:
    &#34;&#34;&#34;Indexes into the list. The first element has index 0.

    Args:
        index: The index to retrieve.

    Returns:
        The value at the given index.
    &#34;&#34;&#34;
    return self[index]</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, mapping: Callable[[~TSource], ~TResult]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TResult]</span>
</code></dt>
<dd>
<div class="desc"><p>Map list.</p>
<p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>The function to transform elements from the input
list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list of transformed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, mapping: Callable[[TSource], TResult]) -&gt; &#34;FrozenList[TResult]&#34;:
    &#34;&#34;&#34;Map list.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection.

    Args:
        mapping: The function to transform elements from the input
            list.

    Returns:
        The list of transformed elements.
    &#34;&#34;&#34;
    return FrozenList((*builtins.map(mapping, self),))</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, *args: Any, **kw: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, *args: Any, **kw: Any) -&gt; Any:
    from pampy import match  # type: ignore

    return match(self, *args, **kw)  # type: ignore</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, *args: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pipe list through the given functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, *args: Any) -&gt; Any:
    &#34;&#34;&#34;Pipe list through the given functions.&#34;&#34;&#34;
    return pipe(self, *args)</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self, count: int) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list after removing the first N elements.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of elements to skip.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list after removing the first N elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
    &#34;&#34;&#34;Returns the list after removing the first N elements.

    Args:
        count: The number of elements to skip.

    Returns:
        The list after removing the first N elements.
    &#34;&#34;&#34;
    return FrozenList(self[count:])</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.skip_last"><code class="name flex">
<span>def <span class="ident">skip_last</span></span>(<span>self, count: int) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip_last(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
    return FrozenList(self[:-count])</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Return tail of List.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self) -&gt; &#34;FrozenList[TSource]&#34;:
    &#34;&#34;&#34;Return tail of List.&#34;&#34;&#34;

    _, *tail = self
    return FrozenList(tail)</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>self, count: int) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first N elements of the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to take.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
    &#34;&#34;&#34;Returns the first N elements of the list.

    Args:
        count: The number of items to take.

    Returns:
        The result list.
    &#34;&#34;&#34;
    return FrozenList(self[:count])</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.take_last"><code class="name flex">
<span>def <span class="ident">take_last</span></span>(<span>self, count: int) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a specified number of contiguous elements from the
end of the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to take.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_last(self, count: int) -&gt; &#34;FrozenList[TSource]&#34;:
    &#34;&#34;&#34;Returns a specified number of contiguous elements from the
    end of the list.

    Args:
        count: The number of items to take.

    Returns:
        The result list.
    &#34;&#34;&#34;
    return FrozenList(self[-count:])</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.try_head"><code class="name flex">
<span>def <span class="ident">try_head</span></span>(<span>self) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first element of the list, or None if the list is
empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_head(self) -&gt; Option[TSource]:
    &#34;&#34;&#34;Returns the first element of the list, or None if the list is
    empty.
    &#34;&#34;&#34;
    return Some(self[0]) if self else Nothing</code></pre>
</details>
</dd>
<dt id="expression.collections.frozenlist.FrozenList.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self, other: <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[TResult]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[~TSource, ~TResult]]</span>
</code></dt>
<dd>
<div class="desc"><p>Combines the two lists into a list of pairs. The two lists
must have equal lengths. .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>The second input list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A single list containing pairs of matching elements from the
input lists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self, other: &#34;FrozenList[TResult]&#34;) -&gt; &#34;FrozenList[Tuple[TSource, TResult]]&#34;:
    &#34;&#34;&#34;Combines the two lists into a list of pairs. The two lists
    must have equal lengths. .

    Args:
        other: The second input list.

    Returns:
        A single list containing pairs of matching elements from the
        input lists.
    &#34;&#34;&#34;
    return FrozenList(builtins.zip(self, other))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="expression.collections" href="index.html">expression.collections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="expression.collections.frozenlist.empty" href="#expression.collections.frozenlist.empty">empty</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="expression.collections.frozenlist.append" href="#expression.collections.frozenlist.append">append</a></code></li>
<li><code><a title="expression.collections.frozenlist.choose" href="#expression.collections.frozenlist.choose">choose</a></code></li>
<li><code><a title="expression.collections.frozenlist.collect" href="#expression.collections.frozenlist.collect">collect</a></code></li>
<li><code><a title="expression.collections.frozenlist.concat" href="#expression.collections.frozenlist.concat">concat</a></code></li>
<li><code><a title="expression.collections.frozenlist.filter" href="#expression.collections.frozenlist.filter">filter</a></code></li>
<li><code><a title="expression.collections.frozenlist.fold" href="#expression.collections.frozenlist.fold">fold</a></code></li>
<li><code><a title="expression.collections.frozenlist.head" href="#expression.collections.frozenlist.head">head</a></code></li>
<li><code><a title="expression.collections.frozenlist.indexed" href="#expression.collections.frozenlist.indexed">indexed</a></code></li>
<li><code><a title="expression.collections.frozenlist.is_empty" href="#expression.collections.frozenlist.is_empty">is_empty</a></code></li>
<li><code><a title="expression.collections.frozenlist.item" href="#expression.collections.frozenlist.item">item</a></code></li>
<li><code><a title="expression.collections.frozenlist.map" href="#expression.collections.frozenlist.map">map</a></code></li>
<li><code><a title="expression.collections.frozenlist.of_option" href="#expression.collections.frozenlist.of_option">of_option</a></code></li>
<li><code><a title="expression.collections.frozenlist.of_seq" href="#expression.collections.frozenlist.of_seq">of_seq</a></code></li>
<li><code><a title="expression.collections.frozenlist.singleton" href="#expression.collections.frozenlist.singleton">singleton</a></code></li>
<li><code><a title="expression.collections.frozenlist.skip" href="#expression.collections.frozenlist.skip">skip</a></code></li>
<li><code><a title="expression.collections.frozenlist.skip_last" href="#expression.collections.frozenlist.skip_last">skip_last</a></code></li>
<li><code><a title="expression.collections.frozenlist.tail" href="#expression.collections.frozenlist.tail">tail</a></code></li>
<li><code><a title="expression.collections.frozenlist.take" href="#expression.collections.frozenlist.take">take</a></code></li>
<li><code><a title="expression.collections.frozenlist.take_last" href="#expression.collections.frozenlist.take_last">take_last</a></code></li>
<li><code><a title="expression.collections.frozenlist.try_head" href="#expression.collections.frozenlist.try_head">try_head</a></code></li>
<li><code><a title="expression.collections.frozenlist.unfold" href="#expression.collections.frozenlist.unfold">unfold</a></code></li>
<li><code><a title="expression.collections.frozenlist.zip" href="#expression.collections.frozenlist.zip">zip</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="expression.collections.frozenlist.FrozenList" href="#expression.collections.frozenlist.FrozenList">FrozenList</a></code></h4>
<ul class="two-column">
<li><code><a title="expression.collections.frozenlist.FrozenList.append" href="#expression.collections.frozenlist.FrozenList.append">append</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.choose" href="#expression.collections.frozenlist.FrozenList.choose">choose</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.collect" href="#expression.collections.frozenlist.FrozenList.collect">collect</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.cons" href="#expression.collections.frozenlist.FrozenList.cons">cons</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.filter" href="#expression.collections.frozenlist.FrozenList.filter">filter</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.fold" href="#expression.collections.frozenlist.FrozenList.fold">fold</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.head" href="#expression.collections.frozenlist.FrozenList.head">head</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.indexed" href="#expression.collections.frozenlist.FrozenList.indexed">indexed</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.is_empty" href="#expression.collections.frozenlist.FrozenList.is_empty">is_empty</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.item" href="#expression.collections.frozenlist.FrozenList.item">item</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.map" href="#expression.collections.frozenlist.FrozenList.map">map</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.match" href="#expression.collections.frozenlist.FrozenList.match">match</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.pipe" href="#expression.collections.frozenlist.FrozenList.pipe">pipe</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.skip" href="#expression.collections.frozenlist.FrozenList.skip">skip</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.skip_last" href="#expression.collections.frozenlist.FrozenList.skip_last">skip_last</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.tail" href="#expression.collections.frozenlist.FrozenList.tail">tail</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.take" href="#expression.collections.frozenlist.FrozenList.take">take</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.take_last" href="#expression.collections.frozenlist.FrozenList.take_last">take_last</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.try_head" href="#expression.collections.frozenlist.FrozenList.try_head">try_head</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.unfold" href="#expression.collections.frozenlist.FrozenList.unfold">unfold</a></code></li>
<li><code><a title="expression.collections.frozenlist.FrozenList.zip" href="#expression.collections.frozenlist.FrozenList.zip">zip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>