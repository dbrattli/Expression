<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.3.dev5+gbec6307" />
<title>expression.collections.seq API documentation</title>
<meta name="description" content="Sequence module â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>expression.collections.seq</code></h1>
</header>
<section id="section-intro">
<p>Sequence module.</p>
<p>Contains a collection of static methods (functions) for operating on
sequences. A sequence is a thin wrapper around <code>Iterable</code> so all
functions take (and return) Python iterables.</p>
<p>All functions takes the source as the last curried
argument, i.e all functions returns a function that takes the source
sequence as the only argument.</p>
<p>Example (functional style):
&gt;&gt;&gt; from expression.collections import seq
&gt;&gt;&gt; xs = seq.of_iterable([1, 2, 3])
&gt;&gt;&gt; ys = xs.pipe(
seq.map(lambda x: x + 1),
seq.filter(lambda x: x &lt; 3)
)</p>
<p>Example (fluent style):
&gt;&gt;&gt; from expression.collections import Seq
&gt;&gt;&gt; xs = Seq([1, 2, 3])
&gt;&gt;&gt; ys = xs.map(lambda x: x + 1).filter(lambda x: x &lt; 3)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Sequence module.

Contains a collection of static methods (functions) for operating on
sequences. A sequence is a thin wrapper around `Iterable` so all
functions take (and return) Python iterables.

All functions takes the source as the last curried
argument, i.e all functions returns a function that takes the source
sequence as the only argument.

Example (functional style):
    &gt;&gt;&gt; from expression.collections import seq
    &gt;&gt;&gt; xs = seq.of_iterable([1, 2, 3])
    &gt;&gt;&gt; ys = xs.pipe(
        seq.map(lambda x: x + 1),
        seq.filter(lambda x: x &lt; 3)
    )

Example (fluent style):
    &gt;&gt;&gt; from expression.collections import Seq
    &gt;&gt;&gt; xs = Seq([1, 2, 3])
    &gt;&gt;&gt; ys = xs.map(lambda x: x + 1).filter(lambda x: x &lt; 3)
&#34;&#34;&#34;
from __future__ import annotations

import builtins
import functools
import itertools
from typing import TYPE_CHECKING, Any, Callable, Iterable, Iterator, Optional, Tuple, TypeVar, cast, overload

from expression.core import Case, Option, SupportsLessThan, identity, pipe

if TYPE_CHECKING:
    from .frozenlist import FrozenList

TSource = TypeVar(&#34;TSource&#34;)
TSourceIn = TypeVar(&#34;TSourceIn&#34;, contravariant=True)
TResult = TypeVar(&#34;TResult&#34;)
TResultOut = TypeVar(&#34;TResultOut&#34;, covariant=True)
TState = TypeVar(&#34;TState&#34;)
TSupportsLessThan = TypeVar(&#34;TSupportsLessThan&#34;, bound=SupportsLessThan)
T1 = TypeVar(&#34;T1&#34;)
T2 = TypeVar(&#34;T2&#34;)
T3 = TypeVar(&#34;T3&#34;)
T4 = TypeVar(&#34;T4&#34;)


class Seq(Iterable[TSource]):
    &#34;&#34;&#34;Sequence type.

    Contains instance methods for dot-chaining operators methods on
    sequences.

    Example:
        &gt;&gt;&gt; xs = Seq([1, 2, 3])
        &gt;&gt;&gt; ys = xs.map(lambda x: x + 1).filter(lambda x: x &lt; 3)
    &#34;&#34;&#34;

    def __init__(self, iterable: Iterable[TSource] = []) -&gt; None:
        self._value = iterable

    @classmethod
    def of(cls, *args: TSource) -&gt; Seq[TSource]:
        return cls(args)

    @classmethod
    def of_iterable(cls, source: Iterable[TSource]) -&gt; Seq[TSource]:
        return cls(source)

    def append(self, *others: Iterable[TSource]) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Wraps the two given enumerations as a single concatenated
        enumeration.&#34;&#34;&#34;
        return Seq(concat(self._value, *others))

    def filter(self, predicate: Callable[[TSource], bool]) -&gt; Seq[TSource]:
        return Seq(filter(predicate)(self))

    def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; Seq[TResult]:
        &#34;&#34;&#34;Choose items from the sequence.

        Applies the given function to each element of the list. Returns
        the list comprised of the results x for each element where the
        function returns `Some(x)`.

        Args:
            chooser: The function to generate options from the elements.

        Returns:
            The list comprising the values selected from the chooser
            function.
        &#34;&#34;&#34;

        xs = pipe(self, choose(chooser))
        return Seq(xs)

    def collect(self, mapping: Callable[[TSource], &#34;Seq[TResult]&#34;]) -&gt; Seq[TResult]:
        xs = pipe(self, collect(mapping))
        return Seq(xs)

    @staticmethod
    def delay(generator: Callable[[], Iterable[TSource]]) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Returns a sequence that is built from the given delayed specification of a
        sequence.

        The input function is evaluated each time an IEnumerator for the sequence
        is requested.

        Args:
            generator: The generating function for the sequence.
        &#34;&#34;&#34;

        return delay(generator)

    @staticmethod
    def empty() -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns empty sequence.&#34;&#34;&#34;
        return Seq()

    def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
        &#34;&#34;&#34;Applies a function to each element of the collection,
        threading an accumulator argument through the computation. If
        the input function is f and the elements are i0...iN then
        computes f (... (f s i0)...) iN

        Args:
            folder: A function that updates the state with each element
                from the sequence.
            state: The initial state.
        Returns:
            The state object after the folding function is applied to
            each element of the sequence.
        &#34;&#34;&#34;
        return functools.reduce(folder, self, state)  # type: ignore

    def head(self) -&gt; TSource:
        &#34;&#34;&#34;Returns the first element of the sequence.&#34;&#34;&#34;

        return head(self)

    def length(self) -&gt; int:
        &#34;&#34;&#34;Returns the length of the sequence.&#34;&#34;&#34;
        return length(self)

    def map(self, mapper: Callable[[TSource], TResult]) -&gt; Seq[TResult]:
        &#34;&#34;&#34;Map sequence.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection.

        Args:
            mapping: A function to transform items from the input sequence.

        Returns:
            The result sequence.
        &#34;&#34;&#34;

        return Seq(pipe(self, map(mapper)))

    def mapi(self, mapping: Callable[[int, TSource], TResult]) -&gt; Seq[TResult]:
        &#34;&#34;&#34;Map list with index.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection. The integer index passed to the function indicates
        the index (from 0) of element being transformed.

        Args:
            mapping: The function to transform elements and their
                indices.

        Returns:
            The list of transformed elements.
        &#34;&#34;&#34;
        return Seq(mapi(mapping)(self))

    @overload
    def match(self) -&gt; Case[Iterable[TSource]]:
        ...

    @overload
    def match(self, pattern: Any) -&gt; Iterable[Iterable[TSource]]:
        ...

    def match(self, pattern: Optional[Any] = None) -&gt; Any:
        case: Case[Iterable[TSource]] = Case(self)
        return case(pattern) if pattern else case

    @overload
    def pipe(self, __fn1: Callable[[&#34;Seq[TSource]&#34;], TResult]) -&gt; TResult:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;Seq[TSource]&#34;], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;Seq[TSource]&#34;], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;Seq[TSource]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe sequence through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    @overload
    @staticmethod
    def range(stop: int) -&gt; Iterable[int]:
        ...

    @overload
    @staticmethod
    def range(start: int, stop: int) -&gt; Iterable[int]:
        ...

    @overload
    @staticmethod
    def range(start: int, stop: int, step: int) -&gt; Iterable[int]:
        ...

    @staticmethod
    def range(*args: int, **kw: int) -&gt; Iterable[int]:
        return range(*args, **kw)

    def scan(self, scanner: Callable[[TState, TSource], TState], state: TState) -&gt; Iterable[TState]:
        &#34;&#34;&#34;Like fold, but computes on-demand and returns the sequence of
        intermediary and final results.

        Args:
            scanner: A function that updates the state with each element
                from the sequence.
            state: The initial state.

        Returns:
            The resulting sequence of computed states.
        &#34;&#34;&#34;
        return Seq(itertools.accumulate(self._value, scanner, initial=state))

    def skip(self, count: int) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns a sequence that skips N elements of the underlying
        sequence and then yields the remaining elements of the sequence.

        Args:
            count: The number of items to skip.
        &#34;&#34;&#34;
        return Seq(pipe(self, skip(count)))

    def sum(self) -&gt; TSource:
        &#34;&#34;&#34;Returns the sum of the elements in the sequence.&#34;&#34;&#34;
        return sum(self)

    def sum_by(self, projection: Callable[[TSource], TResult]) -&gt; TResult:
        &#34;&#34;&#34;Returns the sum of the results generated by applying the
        function to each element of the sequence.&#34;&#34;&#34;
        return pipe(self, sum_by(projection))

    def tail(self) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns a sequence that skips 1 element of the underlying
        sequence and then yields the remaining elements of the
        sequence.&#34;&#34;&#34;
        return self.skip(1)

    def take(self, count: int) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns the first N elements of the sequence.

        Args:
            count: The number of items to take.
        &#34;&#34;&#34;
        return Seq(pipe(self, take(count)))

    def to_list(self) -&gt; &#34;FrozenList[TSource]&#34;:
        return to_list(self)

    @classmethod
    def unfold(cls, generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Returns a list that contains the elements generated by the
        given computation. The given initial state argument is passed to
        the element generator.

        Args:
            generator: A function that takes in the current state and
                returns an option tuple of the next element of the list
                and the next state value.
            state: The initial state.

        Returns:
            The result list.
        &#34;&#34;&#34;

        return pipe(state, unfold(generator))

    def zip(self, other: Iterable[TResult]) -&gt; Iterable[Tuple[TSource, TResult]]:
        &#34;&#34;&#34;Combines the two sequences into a list of pairs. The two
        sequences need not have equal lengths: when one sequence is
        exhausted any remaining elements in the other sequence are
        ignored.

        Args:
            other: The second input sequence.

        Returns:
            The result sequence.
        &#34;&#34;&#34;
        return builtins.zip(self, other)

    def __iter__(self) -&gt; Iterator[TSource]:
        &#34;&#34;&#34;Return iterator for sequence.&#34;&#34;&#34;
        return builtins.iter(self._value)

    def __repr__(self) -&gt; str:
        result = &#34;[&#34;

        for count, x in enumerate(self):
            if count == 0:
                result += str(x)

            elif count == 100:
                result += &#34;; ...&#34;
                break

            else:
                result += &#34;; &#34; + str(x)

        return result + &#34;]&#34;

    def __str__(self) -&gt; str:
        return repr(self)


class SeqGen(Iterable[TSource]):
    &#34;&#34;&#34;Sequence from a generator function.

    We use this to allow multiple iterations over the same sequence
    generated by a generator function.&#34;&#34;&#34;

    def __init__(self, gen: Callable[[], Iterable[TSource]]) -&gt; None:
        self.gen = gen

    def __iter__(self) -&gt; Iterator[TSource]:
        xs = self.gen()
        return builtins.iter(xs)


def append(*others: Iterable[TSource]) -&gt; Callable[[Iterable[TSource]], Iterable[TSource]]:
    &#34;&#34;&#34;Wraps the given enumerations as a single concatenated
    enumeration.&#34;&#34;&#34;

    def _(source: Iterable[TSource]) -&gt; Iterable[TSource]:
        return concat(source, *others)

    return _


def choose(chooser: Callable[[TSource], Option[TResult]]) -&gt; Callable[[Iterable[TSource]], Iterable[TResult]]:
    &#34;&#34;&#34;Choose items from the sequence.

    Applies the given function to each element of the list. Returns
    the list comprised of the results x for each element where the
    function returns `Some(x)`.

    Args:
        chooser: The function to generate options from the elements.

    Returns:
        The list comprising the values selected from the chooser
        function.
    &#34;&#34;&#34;

    def _choose(source: Iterable[TSource]) -&gt; Iterable[TResult]:
        def mapper(x: TSource) -&gt; Iterable[TResult]:
            return chooser(x).to_seq()

        return pipe(source, collect(mapper))

    return _choose


def collect(mapping: Callable[[TSource], Iterable[TResult]]) -&gt; Callable[[Iterable[TSource]], Iterable[TResult]]:
    def _collect(source: Iterable[TSource]) -&gt; Iterable[TResult]:
        def gen():
            for xs in source:
                for x in mapping(xs):
                    yield x

        return SeqGen(gen)

    return _collect


def concat(*iterables: Iterable[TSource]) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Combines the given variable number of enumerations and/or
    enumeration-of-enumerations as a single concatenated
    enumeration.

    Args:
        iterables: The input enumeration-of-enumerations.

    Returns:
        The result sequence.
    &#34;&#34;&#34;

    def gen():
        for it in iterables:
            for element in it:
                yield element

    return SeqGen(gen)


def delay(generator: Callable[[], Iterable[TSource]]) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Returns a sequence that is built from the given delayed
    specification of a sequence.

    The input function is evaluated each time an Iterator for the
    sequence is requested.

    Args:
        generator: The generating function for the sequence.
    &#34;&#34;&#34;
    return SeqGen(generator)


empty: Seq[Any] = Seq()
&#34;&#34;&#34;The empty sequence.&#34;&#34;&#34;


def filter(predicate: Callable[[TSource], bool]) -&gt; Callable[[Iterable[TSource]], Iterable[TSource]]:
    &#34;&#34;&#34;Filter sequence.

    Filters the sequence to a new sequence containing only the
    elements of the sequence for which the given predicate returns
    `True`.

    Args:
        predicate: A function to test whether each item in the
            input sequence should be included in the output.
        source: (curried) The input sequence to to filter.

    Returns:
        A partially applied filter function.
    &#34;&#34;&#34;

    def _filter(source: Iterable[TSource]) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Filter sequence (partially applied).

        Args:
            source: The input sequence to to filter.

        Returns:
            Returns a new collection containing only the elements
            of the collection for which the given predicate returns
            `True`.
        &#34;&#34;&#34;
        return builtins.filter(predicate, source)

    return _filter


def fold(folder: Callable[[TState, TSource], TState], state: TState) -&gt; Callable[[Iterable[TSource]], TState]:
    &#34;&#34;&#34;Applies a function to each element of the collection,
    threading an accumulator argument through the computation. If
    the input function is f and the elements are i0...iN then
    computes f (... (f s i0)...) iN

    Args:
        folder: A function that updates the state with each element
            from the sequence.
        state: The initial state.

    Returns:
        Partially applied fold function that takes a source sequence and
        returns the state object after the folding function is applied
        to each element of the sequence.
    &#34;&#34;&#34;

    def _fold(source: Iterable[TSource]) -&gt; TState:
        &#34;&#34;&#34;Partially applied fold function.
        Returns:
            The state object after the folding function is applied
            to each element of the sequence.
        &#34;&#34;&#34;
        return functools.reduce(folder, source, state)  # type: ignore

    return _fold


def fold_back(folder: Callable[[TSource, TState], TState], source: Iterable[TSource]) -&gt; Callable[[TState], TState]:
    &#34;&#34;&#34;Applies a function to each element of the collection,
    starting from the end, threading an accumulator argument through
    the computation. If the input function is f and the elements are
    i0...iN then computes f i0 (... (f iN s)...)

    Args:
        folder: A function that updates the state with each element
            from the sequence.
        state: The initial state.

    Returns:
        Partially applied fold_back function.
    &#34;&#34;&#34;

    def _fold_back(state: TState) -&gt; TState:
        &#34;&#34;&#34;Partially applied fold_back function.

        Returns:
            The state object after the folding function is applied
            to each element of the sequence.
        &#34;&#34;&#34;
        return functools.reduce(lambda x, y: folder(y, x), reversed(source), state)  # type: ignore

    return _fold_back


def head(source: Iterable[TSource]) -&gt; TSource:
    &#34;&#34;&#34;Return the first element of the sequence.

    Args:
        source: The input sequence.

    Returns:
        The first element of the sequence.

    Raises:
        Raises `ValueError` if the source sequence is empty.
    &#34;&#34;&#34;

    for value in source:
        return value

    raise ValueError(&#34;Sequence contains no elements&#34;)


def init_infinite(initializer: Callable[[int], TSource]) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Generates a new sequence which, when iterated, will return
    successive elements by calling the given function. The results of
    calling the function will not be saved, that is the function will be
    reapplied as necessary to regenerate the elements. The function is
    passed the index of the item being generated.

    Iteration can continue up to `sys.maxsize`.
    &#34;&#34;&#34;

    class Infinite(Iterable[TResult]):
        &#34;&#34;&#34;An infinite iterable where each iterator starts counting at
        0.&#34;&#34;&#34;

        def __init__(self, initializer: Callable[[int], TResult]) -&gt; None:
            self.initializer = initializer

        def __iter__(self) -&gt; Iterator[TResult]:
            return builtins.map(self.initializer, itertools.count(0, 1))

    return Infinite(initializer)


infinite: Iterable[int] = init_infinite(identity)
&#34;&#34;&#34;An infinite iterable.&#34;&#34;&#34;


def iter(action: Callable[[TSource], None]) -&gt; Callable[[Iterable[TSource]], None]:
    &#34;&#34;&#34;Applies the given function to each element of the collection.

    Args:
        action: A function to apply to each element of the sequence.

    Returns:
        A partially applied iter function.
    &#34;&#34;&#34;

    def _iter(source: Iterable[TSource]) -&gt; None:
        &#34;&#34;&#34;A partially applied iter function.

        Note that this function is a pure side effect and returns nothing.

        Args:
            source: The input sequence to apply action to.

        Returns:
            None
        &#34;&#34;&#34;
        for x in source:
            action(x)

    return _iter


def length(source: Seq[Any]) -&gt; int:
    &#34;&#34;&#34;Return the length of the sequence.&#34;&#34;&#34;
    return builtins.sum(1 for _ in source)


def map(mapper: Callable[[TSource], TResult]) -&gt; Callable[[Iterable[TSource]], Iterable[TResult]]:
    &#34;&#34;&#34;Map source sequence.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection.

    Args:
        mapping: A function to transform items from the input sequence.

    Returns:
        Partially applied map function.
    &#34;&#34;&#34;

    def _map(source: Iterable[TSource]) -&gt; Iterable[TResult]:
        &#34;&#34;&#34;Partially applied map function.

        Args:
            source: The input sequence.
        Returns:
            The result sequence.
        &#34;&#34;&#34;

        def gen():
            for x in source:
                yield mapper(x)

        return SeqGen(gen)

    return _map


def mapi(mapping: Callable[[int, TSource], TResult]) -&gt; Callable[[Iterable[TSource]], Iterable[TResult]]:
    &#34;&#34;&#34;Map list with index.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection. The integer index passed to the function indicates
    the index (from 0) of element being transformed.

    Args:
        mapping: The function to transform elements and their
            indices.

    Returns:
        The list of transformed elements.
    &#34;&#34;&#34;

    def _mapi(source: Iterable[TSource]) -&gt; Iterable[TResult]:
        return (*itertools.starmap(mapping, builtins.enumerate(source)),)

    return _mapi


def max(source: Iterable[TSupportsLessThan]) -&gt; TSupportsLessThan:
    &#34;&#34;&#34;Returns the greatest of all elements of the sequence,
    compared via `max()`.&#34;&#34;&#34;

    value: TSupportsLessThan = builtins.max(source)
    return value


def max_by(projection: Callable[[TSource], TSupportsLessThan]) -&gt; Callable[[Iterable[TSource]], TSupportsLessThan]:
    def _max_by(source: Iterable[TSource]) -&gt; TSupportsLessThan:
        return builtins.max(projection(x) for x in source)

    return _max_by


def min(source: Iterable[TSupportsLessThan]) -&gt; TSupportsLessThan:
    &#34;&#34;&#34;Returns the smallest of all elements of the sequence,
    compared via `max()`.&#34;&#34;&#34;

    return builtins.min(source)


def min_by(projection: Callable[[TSource], TSupportsLessThan]) -&gt; Callable[[Iterable[TSource]], TSupportsLessThan]:
    def _min_by(source: Iterable[TSource]) -&gt; TSupportsLessThan:
        return builtins.min(projection(x) for x in source)

    return _min_by


def of(*args: TSource) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Create sequence from iterable.

    Enables fluent dot chaining on the created sequence object.
    &#34;&#34;&#34;
    return Seq(args)


def of_iterable(source: Iterable[TSource]) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Alias to `Seq.of`.&#34;&#34;&#34;
    return Seq(source)


of_list = of_iterable
&#34;&#34;&#34;Alias to `seq.of_iterable`.&#34;&#34;&#34;


@overload
def range(stop: int) -&gt; Iterable[int]:
    ...


@overload
def range(
    start: int,
    stop: int,
) -&gt; Iterable[int]:
    ...


@overload
def range(start: int, stop: int, step: int) -&gt; Iterable[int]:
    ...


def range(*args: int, **kw: int) -&gt; Iterable[int]:
    return Seq(builtins.range(*args, **kw))


def scan(
    scanner: Callable[[TState, TSource], TState], state: TState
) -&gt; Callable[[Iterable[TSource]], Iterable[TState]]:
    &#34;&#34;&#34;Like fold, but computes on-demand and returns the sequence of
    intermediary and final results.

    Args:
        scanner: A function that updates the state with each element
        state: The initial state.
    &#34;&#34;&#34;

    def _scan(source: Iterable[TSource]) -&gt; Iterable[TState]:
        &#34;&#34;&#34;Partially applied scan function.
        Args:
            source: The input sequence.
        Returns:
            The resulting sequence of computed states.
        &#34;&#34;&#34;
        return itertools.accumulate(source, scanner, initial=state)  # type: ignore

    return _scan


def singleton(item: TSource) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns a sequence that yields one item only.

    Args:
        item: The input item.

    Returns:
        The result sequence of one item.
    &#34;&#34;&#34;
    return Seq([item])


def skip(count: int) -&gt; Callable[[Iterable[TSource]], Iterable[TSource]]:
    &#34;&#34;&#34;Returns a sequence that skips N elements of the underlying
    sequence and then yields the remaining elements of the sequence.

    Args:
        count: The number of items to skip.
    &#34;&#34;&#34;

    def _skip(source: Iterable[TSource]) -&gt; Iterable[TSource]:
        def gen():
            for i, n in enumerate(source):
                if i &gt;= count:
                    yield n

        return SeqGen(gen)

    return _skip


def sum(source: Iterable[TSource]) -&gt; TSource:
    &#34;&#34;&#34;Returns the sum of the elements in the sequence.&#34;&#34;&#34;
    ret = builtins.sum(source)
    return cast(TSource, ret)


def sum_by(projection: Callable[[TSource], TResult]) -&gt; Callable[[Iterable[TSource]], TResult]:
    &#34;&#34;&#34;Returns the sum of the results generated by applying the
    function to each element of the sequence.&#34;&#34;&#34;

    def _(source: Iterable[TSource]) -&gt; TResult:
        return sum(projection(x) for x in source)

    return _


def tail(source: Iterable[TSource]) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Returns a sequence that skips 1 element of the underlying
    sequence and then yields the remaining elements of the
    sequence.&#34;&#34;&#34;
    proj = cast(Callable[[Iterable[TSource]], Iterable[TSource]], skip(1))
    return proj(source)


def take(count: int) -&gt; Callable[[Iterable[TSource]], Iterable[TSource]]:
    &#34;&#34;&#34;Returns the first N elements of the sequence.

    Args:
        count: The number of items to take.

    Returns:
        The result sequence.
    &#34;&#34;&#34;

    def _take(source: Iterable[TSource]) -&gt; Iterable[TSource]:
        def gen():
            for i, n in enumerate(source):
                if i &lt; count:
                    yield n

        return SeqGen(gen)

    return _take


def to_list(source: Iterable[TSource]) -&gt; &#34;FrozenList[TSource]&#34;:
    from .frozenlist import FrozenList

    return FrozenList.of_seq(source)


def unfold(generator: Callable[[TState], Option[Tuple[TSource, TState]]]) -&gt; Callable[[TState], Iterable[TSource]]:
    &#34;&#34;&#34;Generates a list that contains the elements generated by the
    given computation. The given initial state argument is passed to
    the element generator.

    Args:
        generator: A function that takes in the current state and
            returns an option tuple of the next element of the list
            and the next state value.

    Returns:
        A partially applied unfold function that takes the state and
        returns the result list.
    &#34;&#34;&#34;

    def _unfold(state: TState) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Returns a list that contains the elements generated by the
        given computation. The given initial state argument is passed to
        the element generator.

        Args:
            state: The initial state.

        Returns:
            The result list.
        &#34;&#34;&#34;
        while True:
            result = generator(state)
            if result.is_none():
                break

            item, state = result.value
            yield item

    return _unfold


def zip(source1: Iterable[TSource]) -&gt; Callable[[Iterable[TResult]], Iterable[Tuple[TSource, TResult]]]:
    &#34;&#34;&#34;Combines the two sequences into a list of pairs. The two
    sequences need not have equal lengths: when one sequence is
    exhausted any remaining elements in the other sequence are
    ignored.

    Args:
        source1: The first input sequence.

    Returns:
        Partially applied zip function.
    &#34;&#34;&#34;

    def _zip(source2: Iterable[TResult]) -&gt; Iterable[Tuple[TSource, TResult]]:
        &#34;&#34;&#34;Combines the two sequences into a list of pairs. The two
        sequences need not have equal lengths: when one sequence is
        exhausted any remaining elements in the other sequence are
        ignored.

        Args:
            source2: The second input sequence.

        Returns:
            The result sequence.
        &#34;&#34;&#34;
        return builtins.zip(source1, source2)

    return _zip


__all__ = [
    &#34;Seq&#34;,
    &#34;append&#34;,
    &#34;choose&#34;,
    &#34;concat&#34;,
    &#34;collect&#34;,
    &#34;delay&#34;,
    &#34;empty&#34;,
    &#34;filter&#34;,
    &#34;fold&#34;,
    &#34;fold_back&#34;,
    &#34;head&#34;,
    &#34;iter&#34;,
    &#34;map&#34;,
    &#34;mapi&#34;,
    &#34;max&#34;,
    &#34;min&#34;,
    &#34;min_by&#34;,
    &#34;of&#34;,
    &#34;of_list&#34;,
    &#34;of_iterable&#34;,
    &#34;range&#34;,
    &#34;scan&#34;,
    &#34;skip&#34;,
    &#34;singleton&#34;,
    &#34;sum&#34;,
    &#34;sum_by&#34;,
    &#34;tail&#34;,
    &#34;take&#34;,
    &#34;unfold&#34;,
    &#34;zip&#34;,
]</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="expression.collections.seq.empty"><code class="name">var <span class="ident">empty</span> :Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></code></dt>
<dd>
<div class="desc"><p>The empty sequence.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="expression.collections.seq.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>*others:Â Iterable[TSource]) â€‘>Â Callable[[Iterable[~TSource]],Â Iterable[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps the given enumerations as a single concatenated
enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(*others: Iterable[TSource]) -&gt; Callable[[Iterable[TSource]], Iterable[TSource]]:
    &#34;&#34;&#34;Wraps the given enumerations as a single concatenated
    enumeration.&#34;&#34;&#34;

    def _(source: Iterable[TSource]) -&gt; Iterable[TSource]:
        return concat(source, *others)

    return _</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.choose"><code class="name flex">
<span>def <span class="ident">choose</span></span>(<span>chooser:Â Callable[[TSource],Â Option[TResult]]) â€‘>Â Callable[[Iterable[~TSource]],Â Iterable[~TResult]]</span>
</code></dt>
<dd>
<div class="desc"><p>Choose items from the sequence.</p>
<p>Applies the given function to each element of the list. Returns
the list comprised of the results x for each element where the
function returns <code>Some(x)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chooser</code></strong></dt>
<dd>The function to generate options from the elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list comprising the values selected from the chooser
function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose(chooser: Callable[[TSource], Option[TResult]]) -&gt; Callable[[Iterable[TSource]], Iterable[TResult]]:
    &#34;&#34;&#34;Choose items from the sequence.

    Applies the given function to each element of the list. Returns
    the list comprised of the results x for each element where the
    function returns `Some(x)`.

    Args:
        chooser: The function to generate options from the elements.

    Returns:
        The list comprising the values selected from the chooser
        function.
    &#34;&#34;&#34;

    def _choose(source: Iterable[TSource]) -&gt; Iterable[TResult]:
        def mapper(x: TSource) -&gt; Iterable[TResult]:
            return chooser(x).to_seq()

        return pipe(source, collect(mapper))

    return _choose</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.collect"><code class="name flex">
<span>def <span class="ident">collect</span></span>(<span>mapping:Â Callable[[TSource],Â Iterable[TResult]]) â€‘>Â Callable[[Iterable[~TSource]],Â Iterable[~TResult]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect(mapping: Callable[[TSource], Iterable[TResult]]) -&gt; Callable[[Iterable[TSource]], Iterable[TResult]]:
    def _collect(source: Iterable[TSource]) -&gt; Iterable[TResult]:
        def gen():
            for xs in source:
                for x in mapping(xs):
                    yield x

        return SeqGen(gen)

    return _collect</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>*iterables:Â Iterable[TSource]) â€‘>Â Iterable[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Combines the given variable number of enumerations and/or
enumeration-of-enumerations as a single concatenated
enumeration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>iterables</code></strong></dt>
<dd>The input enumeration-of-enumerations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(*iterables: Iterable[TSource]) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Combines the given variable number of enumerations and/or
    enumeration-of-enumerations as a single concatenated
    enumeration.

    Args:
        iterables: The input enumeration-of-enumerations.

    Returns:
        The result sequence.
    &#34;&#34;&#34;

    def gen():
        for it in iterables:
            for element in it:
                yield element

    return SeqGen(gen)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>generator:Â Callable[[],Â Iterable[TSource]]) â€‘>Â Iterable[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that is built from the given delayed
specification of a sequence.</p>
<p>The input function is evaluated each time an Iterator for the
sequence is requested.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>The generating function for the sequence.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay(generator: Callable[[], Iterable[TSource]]) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Returns a sequence that is built from the given delayed
    specification of a sequence.

    The input function is evaluated each time an Iterator for the
    sequence is requested.

    Args:
        generator: The generating function for the sequence.
    &#34;&#34;&#34;
    return SeqGen(generator)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>predicate:Â Callable[[TSource],Â bool]) â€‘>Â Callable[[Iterable[~TSource]],Â Iterable[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Filter sequence.</p>
<p>Filters the sequence to a new sequence containing only the
elements of the sequence for which the given predicate returns
<code>True</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>A function to test whether each item in the
input sequence should be included in the output.</dd>
<dt><strong><code>source</code></strong></dt>
<dd>(curried) The input sequence to to filter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A partially applied filter function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(predicate: Callable[[TSource], bool]) -&gt; Callable[[Iterable[TSource]], Iterable[TSource]]:
    &#34;&#34;&#34;Filter sequence.

    Filters the sequence to a new sequence containing only the
    elements of the sequence for which the given predicate returns
    `True`.

    Args:
        predicate: A function to test whether each item in the
            input sequence should be included in the output.
        source: (curried) The input sequence to to filter.

    Returns:
        A partially applied filter function.
    &#34;&#34;&#34;

    def _filter(source: Iterable[TSource]) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Filter sequence (partially applied).

        Args:
            source: The input sequence to to filter.

        Returns:
            Returns a new collection containing only the elements
            of the collection for which the given predicate returns
            `True`.
        &#34;&#34;&#34;
        return builtins.filter(predicate, source)

    return _filter</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>folder:Â Callable[[TState,Â TSource],Â TState], state:Â TState) â€‘>Â Callable[[Iterable[~TSource]],Â ~TState]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a function to each element of the collection,
threading an accumulator argument through the computation. If
the input function is f and the elements are i0&hellip;iN then
computes f (&hellip; (f s i0)&hellip;) iN</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder</code></strong></dt>
<dd>A function that updates the state with each element
from the sequence.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied fold function that takes a source sequence and
returns the state object after the folding function is applied
to each element of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(folder: Callable[[TState, TSource], TState], state: TState) -&gt; Callable[[Iterable[TSource]], TState]:
    &#34;&#34;&#34;Applies a function to each element of the collection,
    threading an accumulator argument through the computation. If
    the input function is f and the elements are i0...iN then
    computes f (... (f s i0)...) iN

    Args:
        folder: A function that updates the state with each element
            from the sequence.
        state: The initial state.

    Returns:
        Partially applied fold function that takes a source sequence and
        returns the state object after the folding function is applied
        to each element of the sequence.
    &#34;&#34;&#34;

    def _fold(source: Iterable[TSource]) -&gt; TState:
        &#34;&#34;&#34;Partially applied fold function.
        Returns:
            The state object after the folding function is applied
            to each element of the sequence.
        &#34;&#34;&#34;
        return functools.reduce(folder, source, state)  # type: ignore

    return _fold</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.fold_back"><code class="name flex">
<span>def <span class="ident">fold_back</span></span>(<span>folder:Â Callable[[TSource,Â TState],Â TState], source:Â Iterable[TSource]) â€‘>Â Callable[[~TState],Â ~TState]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a function to each element of the collection,
starting from the end, threading an accumulator argument through
the computation. If the input function is f and the elements are
i0&hellip;iN then computes f i0 (&hellip; (f iN s)&hellip;)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder</code></strong></dt>
<dd>A function that updates the state with each element
from the sequence.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied fold_back function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold_back(folder: Callable[[TSource, TState], TState], source: Iterable[TSource]) -&gt; Callable[[TState], TState]:
    &#34;&#34;&#34;Applies a function to each element of the collection,
    starting from the end, threading an accumulator argument through
    the computation. If the input function is f and the elements are
    i0...iN then computes f i0 (... (f iN s)...)

    Args:
        folder: A function that updates the state with each element
            from the sequence.
        state: The initial state.

    Returns:
        Partially applied fold_back function.
    &#34;&#34;&#34;

    def _fold_back(state: TState) -&gt; TState:
        &#34;&#34;&#34;Partially applied fold_back function.

        Returns:
            The state object after the folding function is applied
            to each element of the sequence.
        &#34;&#34;&#34;
        return functools.reduce(lambda x, y: folder(y, x), reversed(source), state)  # type: ignore

    return _fold_back</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>source:Â Iterable[TSource]) â€‘>Â ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Return the first element of the sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>The input sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The first element of the sequence.</p>
<h2 id="raises">Raises</h2>
<p>Raises <code>ValueError</code> if the source sequence is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(source: Iterable[TSource]) -&gt; TSource:
    &#34;&#34;&#34;Return the first element of the sequence.

    Args:
        source: The input sequence.

    Returns:
        The first element of the sequence.

    Raises:
        Raises `ValueError` if the source sequence is empty.
    &#34;&#34;&#34;

    for value in source:
        return value

    raise ValueError(&#34;Sequence contains no elements&#34;)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.iter"><code class="name flex">
<span>def <span class="ident">iter</span></span>(<span>action:Â Callable[[TSource],Â None]) â€‘>Â Callable[[Iterable[~TSource]],Â NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the given function to each element of the collection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong></dt>
<dd>A function to apply to each element of the sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A partially applied iter function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter(action: Callable[[TSource], None]) -&gt; Callable[[Iterable[TSource]], None]:
    &#34;&#34;&#34;Applies the given function to each element of the collection.

    Args:
        action: A function to apply to each element of the sequence.

    Returns:
        A partially applied iter function.
    &#34;&#34;&#34;

    def _iter(source: Iterable[TSource]) -&gt; None:
        &#34;&#34;&#34;A partially applied iter function.

        Note that this function is a pure side effect and returns nothing.

        Args:
            source: The input sequence to apply action to.

        Returns:
            None
        &#34;&#34;&#34;
        for x in source:
            action(x)

    return _iter</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>mapper:Â Callable[[TSource],Â TResult]) â€‘>Â Callable[[Iterable[~TSource]],Â Iterable[~TResult]]</span>
</code></dt>
<dd>
<div class="desc"><p>Map source sequence.</p>
<p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>A function to transform items from the input sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied map function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(mapper: Callable[[TSource], TResult]) -&gt; Callable[[Iterable[TSource]], Iterable[TResult]]:
    &#34;&#34;&#34;Map source sequence.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection.

    Args:
        mapping: A function to transform items from the input sequence.

    Returns:
        Partially applied map function.
    &#34;&#34;&#34;

    def _map(source: Iterable[TSource]) -&gt; Iterable[TResult]:
        &#34;&#34;&#34;Partially applied map function.

        Args:
            source: The input sequence.
        Returns:
            The result sequence.
        &#34;&#34;&#34;

        def gen():
            for x in source:
                yield mapper(x)

        return SeqGen(gen)

    return _map</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.mapi"><code class="name flex">
<span>def <span class="ident">mapi</span></span>(<span>mapping:Â Callable[[int,Â TSource],Â TResult]) â€‘>Â Callable[[Iterable[~TSource]],Â Iterable[~TResult]]</span>
</code></dt>
<dd>
<div class="desc"><p>Map list with index.</p>
<p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection. The integer index passed to the function indicates
the index (from 0) of element being transformed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>The function to transform elements and their
indices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list of transformed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mapi(mapping: Callable[[int, TSource], TResult]) -&gt; Callable[[Iterable[TSource]], Iterable[TResult]]:
    &#34;&#34;&#34;Map list with index.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection. The integer index passed to the function indicates
    the index (from 0) of element being transformed.

    Args:
        mapping: The function to transform elements and their
            indices.

    Returns:
        The list of transformed elements.
    &#34;&#34;&#34;

    def _mapi(source: Iterable[TSource]) -&gt; Iterable[TResult]:
        return (*itertools.starmap(mapping, builtins.enumerate(source)),)

    return _mapi</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.max"><code class="name flex">
<span>def <span class="ident">max</span></span>(<span>source:Â Iterable[TSupportsLessThan]) â€‘>Â ~TSupportsLessThan</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the greatest of all elements of the sequence,
compared via <code><a title="expression.collections.seq.max" href="#expression.collections.seq.max">max()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max(source: Iterable[TSupportsLessThan]) -&gt; TSupportsLessThan:
    &#34;&#34;&#34;Returns the greatest of all elements of the sequence,
    compared via `max()`.&#34;&#34;&#34;

    value: TSupportsLessThan = builtins.max(source)
    return value</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.min"><code class="name flex">
<span>def <span class="ident">min</span></span>(<span>source:Â Iterable[TSupportsLessThan]) â€‘>Â ~TSupportsLessThan</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the smallest of all elements of the sequence,
compared via <code><a title="expression.collections.seq.max" href="#expression.collections.seq.max">max()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min(source: Iterable[TSupportsLessThan]) -&gt; TSupportsLessThan:
    &#34;&#34;&#34;Returns the smallest of all elements of the sequence,
    compared via `max()`.&#34;&#34;&#34;

    return builtins.min(source)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.min_by"><code class="name flex">
<span>def <span class="ident">min_by</span></span>(<span>projection:Â Callable[[TSource],Â TSupportsLessThan]) â€‘>Â Callable[[Iterable[~TSource]],Â ~TSupportsLessThan]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_by(projection: Callable[[TSource], TSupportsLessThan]) -&gt; Callable[[Iterable[TSource]], TSupportsLessThan]:
    def _min_by(source: Iterable[TSource]) -&gt; TSupportsLessThan:
        return builtins.min(projection(x) for x in source)

    return _min_by</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>*args:Â TSource) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create sequence from iterable.</p>
<p>Enables fluent dot chaining on the created sequence object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of(*args: TSource) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Create sequence from iterable.

    Enables fluent dot chaining on the created sequence object.
    &#34;&#34;&#34;
    return Seq(args)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.of_iterable"><code class="name flex">
<span>def <span class="ident">of_iterable</span></span>(<span>source:Â Iterable[TSource]) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="expression.collections.seq.Seq.of" href="#expression.collections.seq.Seq.of">Seq.of()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_iterable(source: Iterable[TSource]) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Alias to `Seq.of`.&#34;&#34;&#34;
    return Seq(source)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.of_list"><code class="name flex">
<span>def <span class="ident">of_list</span></span>(<span>source:Â Iterable[TSource]) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="expression.collections.seq.Seq.of" href="#expression.collections.seq.Seq.of">Seq.of()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_iterable(source: Iterable[TSource]) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Alias to `Seq.of`.&#34;&#34;&#34;
    return Seq(source)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>*args:Â int, **kw:Â int) â€‘>Â Iterable[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def range(*args: int, **kw: int) -&gt; Iterable[int]:
    return Seq(builtins.range(*args, **kw))</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>scanner:Â Callable[[TState,Â TSource],Â TState], state:Â TState) â€‘>Â Callable[[Iterable[~TSource]],Â Iterable[~TState]]</span>
</code></dt>
<dd>
<div class="desc"><p>Like fold, but computes on-demand and returns the sequence of
intermediary and final results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scanner</code></strong></dt>
<dd>A function that updates the state with each element</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan(
    scanner: Callable[[TState, TSource], TState], state: TState
) -&gt; Callable[[Iterable[TSource]], Iterable[TState]]:
    &#34;&#34;&#34;Like fold, but computes on-demand and returns the sequence of
    intermediary and final results.

    Args:
        scanner: A function that updates the state with each element
        state: The initial state.
    &#34;&#34;&#34;

    def _scan(source: Iterable[TSource]) -&gt; Iterable[TState]:
        &#34;&#34;&#34;Partially applied scan function.
        Args:
            source: The input sequence.
        Returns:
            The resulting sequence of computed states.
        &#34;&#34;&#34;
        return itertools.accumulate(source, scanner, initial=state)  # type: ignore

    return _scan</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.singleton"><code class="name flex">
<span>def <span class="ident">singleton</span></span>(<span>item:Â TSource) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that yields one item only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>The input item.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result sequence of one item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def singleton(item: TSource) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns a sequence that yields one item only.

    Args:
        item: The input item.

    Returns:
        The result sequence of one item.
    &#34;&#34;&#34;
    return Seq([item])</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>count:Â int) â€‘>Â Callable[[Iterable[~TSource]],Â Iterable[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that skips N elements of the underlying
sequence and then yields the remaining elements of the sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to skip.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(count: int) -&gt; Callable[[Iterable[TSource]], Iterable[TSource]]:
    &#34;&#34;&#34;Returns a sequence that skips N elements of the underlying
    sequence and then yields the remaining elements of the sequence.

    Args:
        count: The number of items to skip.
    &#34;&#34;&#34;

    def _skip(source: Iterable[TSource]) -&gt; Iterable[TSource]:
        def gen():
            for i, n in enumerate(source):
                if i &gt;= count:
                    yield n

        return SeqGen(gen)

    return _skip</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>source:Â Iterable[TSource]) â€‘>Â ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of the elements in the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(source: Iterable[TSource]) -&gt; TSource:
    &#34;&#34;&#34;Returns the sum of the elements in the sequence.&#34;&#34;&#34;
    ret = builtins.sum(source)
    return cast(TSource, ret)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.sum_by"><code class="name flex">
<span>def <span class="ident">sum_by</span></span>(<span>projection:Â Callable[[TSource],Â TResult]) â€‘>Â Callable[[Iterable[~TSource]],Â ~TResult]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of the results generated by applying the
function to each element of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_by(projection: Callable[[TSource], TResult]) -&gt; Callable[[Iterable[TSource]], TResult]:
    &#34;&#34;&#34;Returns the sum of the results generated by applying the
    function to each element of the sequence.&#34;&#34;&#34;

    def _(source: Iterable[TSource]) -&gt; TResult:
        return sum(projection(x) for x in source)

    return _</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>source:Â Iterable[TSource]) â€‘>Â Iterable[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that skips 1 element of the underlying
sequence and then yields the remaining elements of the
sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(source: Iterable[TSource]) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Returns a sequence that skips 1 element of the underlying
    sequence and then yields the remaining elements of the
    sequence.&#34;&#34;&#34;
    proj = cast(Callable[[Iterable[TSource]], Iterable[TSource]], skip(1))
    return proj(source)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>count:Â int) â€‘>Â Callable[[Iterable[~TSource]],Â Iterable[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first N elements of the sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to take.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(count: int) -&gt; Callable[[Iterable[TSource]], Iterable[TSource]]:
    &#34;&#34;&#34;Returns the first N elements of the sequence.

    Args:
        count: The number of items to take.

    Returns:
        The result sequence.
    &#34;&#34;&#34;

    def _take(source: Iterable[TSource]) -&gt; Iterable[TSource]:
        def gen():
            for i, n in enumerate(source):
                if i &lt; count:
                    yield n

        return SeqGen(gen)

    return _take</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.unfold"><code class="name flex">
<span>def <span class="ident">unfold</span></span>(<span>generator:Â Callable[[TState],Â Option[Tuple[TSource,Â TState]]]) â€‘>Â Callable[[~TState],Â Iterable[~TSource]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a list that contains the elements generated by the
given computation. The given initial state argument is passed to
the element generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>A function that takes in the current state and
returns an option tuple of the next element of the list
and the next state value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A partially applied unfold function that takes the state and
returns the result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unfold(generator: Callable[[TState], Option[Tuple[TSource, TState]]]) -&gt; Callable[[TState], Iterable[TSource]]:
    &#34;&#34;&#34;Generates a list that contains the elements generated by the
    given computation. The given initial state argument is passed to
    the element generator.

    Args:
        generator: A function that takes in the current state and
            returns an option tuple of the next element of the list
            and the next state value.

    Returns:
        A partially applied unfold function that takes the state and
        returns the result list.
    &#34;&#34;&#34;

    def _unfold(state: TState) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Returns a list that contains the elements generated by the
        given computation. The given initial state argument is passed to
        the element generator.

        Args:
            state: The initial state.

        Returns:
            The result list.
        &#34;&#34;&#34;
        while True:
            result = generator(state)
            if result.is_none():
                break

            item, state = result.value
            yield item

    return _unfold</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>source1:Â Iterable[TSource]) â€‘>Â Callable[[Iterable[~TResult]],Â Iterable[Tuple[~TSource,Â ~TResult]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Combines the two sequences into a list of pairs. The two
sequences need not have equal lengths: when one sequence is
exhausted any remaining elements in the other sequence are
ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source1</code></strong></dt>
<dd>The first input sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied zip function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(source1: Iterable[TSource]) -&gt; Callable[[Iterable[TResult]], Iterable[Tuple[TSource, TResult]]]:
    &#34;&#34;&#34;Combines the two sequences into a list of pairs. The two
    sequences need not have equal lengths: when one sequence is
    exhausted any remaining elements in the other sequence are
    ignored.

    Args:
        source1: The first input sequence.

    Returns:
        Partially applied zip function.
    &#34;&#34;&#34;

    def _zip(source2: Iterable[TResult]) -&gt; Iterable[Tuple[TSource, TResult]]:
        &#34;&#34;&#34;Combines the two sequences into a list of pairs. The two
        sequences need not have equal lengths: when one sequence is
        exhausted any remaining elements in the other sequence are
        ignored.

        Args:
            source2: The second input sequence.

        Returns:
            The result sequence.
        &#34;&#34;&#34;
        return builtins.zip(source1, source2)

    return _zip</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="expression.collections.seq.Seq"><code class="flex name class">
<span>class <span class="ident">Seq</span></span>
<span>(</span><span>iterable:Â Iterable[TSource]Â =Â [])</span>
</code></dt>
<dd>
<div class="desc"><p>Sequence type.</p>
<p>Contains instance methods for dot-chaining operators methods on
sequences.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; xs = Seq([1, 2, 3])
&gt;&gt;&gt; ys = xs.map(lambda x: x + 1).filter(lambda x: x &lt; 3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Seq(Iterable[TSource]):
    &#34;&#34;&#34;Sequence type.

    Contains instance methods for dot-chaining operators methods on
    sequences.

    Example:
        &gt;&gt;&gt; xs = Seq([1, 2, 3])
        &gt;&gt;&gt; ys = xs.map(lambda x: x + 1).filter(lambda x: x &lt; 3)
    &#34;&#34;&#34;

    def __init__(self, iterable: Iterable[TSource] = []) -&gt; None:
        self._value = iterable

    @classmethod
    def of(cls, *args: TSource) -&gt; Seq[TSource]:
        return cls(args)

    @classmethod
    def of_iterable(cls, source: Iterable[TSource]) -&gt; Seq[TSource]:
        return cls(source)

    def append(self, *others: Iterable[TSource]) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Wraps the two given enumerations as a single concatenated
        enumeration.&#34;&#34;&#34;
        return Seq(concat(self._value, *others))

    def filter(self, predicate: Callable[[TSource], bool]) -&gt; Seq[TSource]:
        return Seq(filter(predicate)(self))

    def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; Seq[TResult]:
        &#34;&#34;&#34;Choose items from the sequence.

        Applies the given function to each element of the list. Returns
        the list comprised of the results x for each element where the
        function returns `Some(x)`.

        Args:
            chooser: The function to generate options from the elements.

        Returns:
            The list comprising the values selected from the chooser
            function.
        &#34;&#34;&#34;

        xs = pipe(self, choose(chooser))
        return Seq(xs)

    def collect(self, mapping: Callable[[TSource], &#34;Seq[TResult]&#34;]) -&gt; Seq[TResult]:
        xs = pipe(self, collect(mapping))
        return Seq(xs)

    @staticmethod
    def delay(generator: Callable[[], Iterable[TSource]]) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Returns a sequence that is built from the given delayed specification of a
        sequence.

        The input function is evaluated each time an IEnumerator for the sequence
        is requested.

        Args:
            generator: The generating function for the sequence.
        &#34;&#34;&#34;

        return delay(generator)

    @staticmethod
    def empty() -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns empty sequence.&#34;&#34;&#34;
        return Seq()

    def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
        &#34;&#34;&#34;Applies a function to each element of the collection,
        threading an accumulator argument through the computation. If
        the input function is f and the elements are i0...iN then
        computes f (... (f s i0)...) iN

        Args:
            folder: A function that updates the state with each element
                from the sequence.
            state: The initial state.
        Returns:
            The state object after the folding function is applied to
            each element of the sequence.
        &#34;&#34;&#34;
        return functools.reduce(folder, self, state)  # type: ignore

    def head(self) -&gt; TSource:
        &#34;&#34;&#34;Returns the first element of the sequence.&#34;&#34;&#34;

        return head(self)

    def length(self) -&gt; int:
        &#34;&#34;&#34;Returns the length of the sequence.&#34;&#34;&#34;
        return length(self)

    def map(self, mapper: Callable[[TSource], TResult]) -&gt; Seq[TResult]:
        &#34;&#34;&#34;Map sequence.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection.

        Args:
            mapping: A function to transform items from the input sequence.

        Returns:
            The result sequence.
        &#34;&#34;&#34;

        return Seq(pipe(self, map(mapper)))

    def mapi(self, mapping: Callable[[int, TSource], TResult]) -&gt; Seq[TResult]:
        &#34;&#34;&#34;Map list with index.

        Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection. The integer index passed to the function indicates
        the index (from 0) of element being transformed.

        Args:
            mapping: The function to transform elements and their
                indices.

        Returns:
            The list of transformed elements.
        &#34;&#34;&#34;
        return Seq(mapi(mapping)(self))

    @overload
    def match(self) -&gt; Case[Iterable[TSource]]:
        ...

    @overload
    def match(self, pattern: Any) -&gt; Iterable[Iterable[TSource]]:
        ...

    def match(self, pattern: Optional[Any] = None) -&gt; Any:
        case: Case[Iterable[TSource]] = Case(self)
        return case(pattern) if pattern else case

    @overload
    def pipe(self, __fn1: Callable[[&#34;Seq[TSource]&#34;], TResult]) -&gt; TResult:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;Seq[TSource]&#34;], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(self, __fn1: Callable[[&#34;Seq[TSource]&#34;], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[&#34;Seq[TSource]&#34;], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe sequence through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    @overload
    @staticmethod
    def range(stop: int) -&gt; Iterable[int]:
        ...

    @overload
    @staticmethod
    def range(start: int, stop: int) -&gt; Iterable[int]:
        ...

    @overload
    @staticmethod
    def range(start: int, stop: int, step: int) -&gt; Iterable[int]:
        ...

    @staticmethod
    def range(*args: int, **kw: int) -&gt; Iterable[int]:
        return range(*args, **kw)

    def scan(self, scanner: Callable[[TState, TSource], TState], state: TState) -&gt; Iterable[TState]:
        &#34;&#34;&#34;Like fold, but computes on-demand and returns the sequence of
        intermediary and final results.

        Args:
            scanner: A function that updates the state with each element
                from the sequence.
            state: The initial state.

        Returns:
            The resulting sequence of computed states.
        &#34;&#34;&#34;
        return Seq(itertools.accumulate(self._value, scanner, initial=state))

    def skip(self, count: int) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns a sequence that skips N elements of the underlying
        sequence and then yields the remaining elements of the sequence.

        Args:
            count: The number of items to skip.
        &#34;&#34;&#34;
        return Seq(pipe(self, skip(count)))

    def sum(self) -&gt; TSource:
        &#34;&#34;&#34;Returns the sum of the elements in the sequence.&#34;&#34;&#34;
        return sum(self)

    def sum_by(self, projection: Callable[[TSource], TResult]) -&gt; TResult:
        &#34;&#34;&#34;Returns the sum of the results generated by applying the
        function to each element of the sequence.&#34;&#34;&#34;
        return pipe(self, sum_by(projection))

    def tail(self) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns a sequence that skips 1 element of the underlying
        sequence and then yields the remaining elements of the
        sequence.&#34;&#34;&#34;
        return self.skip(1)

    def take(self, count: int) -&gt; Seq[TSource]:
        &#34;&#34;&#34;Returns the first N elements of the sequence.

        Args:
            count: The number of items to take.
        &#34;&#34;&#34;
        return Seq(pipe(self, take(count)))

    def to_list(self) -&gt; &#34;FrozenList[TSource]&#34;:
        return to_list(self)

    @classmethod
    def unfold(cls, generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; Iterable[TSource]:
        &#34;&#34;&#34;Returns a list that contains the elements generated by the
        given computation. The given initial state argument is passed to
        the element generator.

        Args:
            generator: A function that takes in the current state and
                returns an option tuple of the next element of the list
                and the next state value.
            state: The initial state.

        Returns:
            The result list.
        &#34;&#34;&#34;

        return pipe(state, unfold(generator))

    def zip(self, other: Iterable[TResult]) -&gt; Iterable[Tuple[TSource, TResult]]:
        &#34;&#34;&#34;Combines the two sequences into a list of pairs. The two
        sequences need not have equal lengths: when one sequence is
        exhausted any remaining elements in the other sequence are
        ignored.

        Args:
            other: The second input sequence.

        Returns:
            The result sequence.
        &#34;&#34;&#34;
        return builtins.zip(self, other)

    def __iter__(self) -&gt; Iterator[TSource]:
        &#34;&#34;&#34;Return iterator for sequence.&#34;&#34;&#34;
        return builtins.iter(self._value)

    def __repr__(self) -&gt; str:
        result = &#34;[&#34;

        for count, x in enumerate(self):
            if count == 0:
                result += str(x)

            elif count == 100:
                result += &#34;; ...&#34;
                break

            else:
                result += &#34;; &#34; + str(x)

        return result + &#34;]&#34;

    def __str__(self) -&gt; str:
        return repr(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Iterable</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="expression.collections.seq.Seq.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>generator:Â Callable[[],Â Iterable[TSource]]) â€‘>Â Iterable[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that is built from the given delayed specification of a
sequence.</p>
<p>The input function is evaluated each time an IEnumerator for the sequence
is requested.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>The generating function for the sequence.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def delay(generator: Callable[[], Iterable[TSource]]) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Returns a sequence that is built from the given delayed specification of a
    sequence.

    The input function is evaluated each time an IEnumerator for the sequence
    is requested.

    Args:
        generator: The generating function for the sequence.
    &#34;&#34;&#34;

    return delay(generator)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns empty sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty() -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns empty sequence.&#34;&#34;&#34;
    return Seq()</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>*args:Â TSource) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(cls, *args: TSource) -&gt; Seq[TSource]:
    return cls(args)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.of_iterable"><code class="name flex">
<span>def <span class="ident">of_iterable</span></span>(<span>source:Â Iterable[TSource]) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of_iterable(cls, source: Iterable[TSource]) -&gt; Seq[TSource]:
    return cls(source)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>*args:Â int, **kw:Â int) â€‘>Â Iterable[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def range(*args: int, **kw: int) -&gt; Iterable[int]:
    return range(*args, **kw)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.unfold"><code class="name flex">
<span>def <span class="ident">unfold</span></span>(<span>generator:Â Callable[[TState],Â Option[Tuple[TSource,Â TState]]], state:Â TState) â€‘>Â Iterable[~TSource]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list that contains the elements generated by the
given computation. The given initial state argument is passed to
the element generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>A function that takes in the current state and
returns an option tuple of the next element of the list
and the next state value.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def unfold(cls, generator: Callable[[TState], Option[Tuple[TSource, TState]]], state: TState) -&gt; Iterable[TSource]:
    &#34;&#34;&#34;Returns a list that contains the elements generated by the
    given computation. The given initial state argument is passed to
    the element generator.

    Args:
        generator: A function that takes in the current state and
            returns an option tuple of the next element of the list
            and the next state value.
        state: The initial state.

    Returns:
        The result list.
    &#34;&#34;&#34;

    return pipe(state, unfold(generator))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="expression.collections.seq.Seq.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, *others:Â Iterable[TSource]) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Wraps the two given enumerations as a single concatenated
enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, *others: Iterable[TSource]) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Wraps the two given enumerations as a single concatenated
    enumeration.&#34;&#34;&#34;
    return Seq(concat(self._value, *others))</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.choose"><code class="name flex">
<span>def <span class="ident">choose</span></span>(<span>self, chooser:Â Callable[[TSource],Â Option[TResult]]) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Choose items from the sequence.</p>
<p>Applies the given function to each element of the list. Returns
the list comprised of the results x for each element where the
function returns <code>Some(x)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chooser</code></strong></dt>
<dd>The function to generate options from the elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list comprising the values selected from the chooser
function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose(self, chooser: Callable[[TSource], Option[TResult]]) -&gt; Seq[TResult]:
    &#34;&#34;&#34;Choose items from the sequence.

    Applies the given function to each element of the list. Returns
    the list comprised of the results x for each element where the
    function returns `Some(x)`.

    Args:
        chooser: The function to generate options from the elements.

    Returns:
        The list comprising the values selected from the chooser
        function.
    &#34;&#34;&#34;

    xs = pipe(self, choose(chooser))
    return Seq(xs)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.collect"><code class="name flex">
<span>def <span class="ident">collect</span></span>(<span>self, mapping:Â "Callable[[TSource],Â '<a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a>[TResult]']") â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect(self, mapping: Callable[[TSource], &#34;Seq[TResult]&#34;]) -&gt; Seq[TResult]:
    xs = pipe(self, collect(mapping))
    return Seq(xs)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, predicate:Â Callable[[TSource],Â bool]) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, predicate: Callable[[TSource], bool]) -&gt; Seq[TSource]:
    return Seq(filter(predicate)(self))</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, folder:Â Callable[[TState,Â TSource],Â TState], state:Â TState) â€‘>Â ~TState</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a function to each element of the collection,
threading an accumulator argument through the computation. If
the input function is f and the elements are i0&hellip;iN then
computes f (&hellip; (f s i0)&hellip;) iN</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder</code></strong></dt>
<dd>A function that updates the state with each element
from the sequence.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The state object after the folding function is applied to
each element of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, folder: Callable[[TState, TSource], TState], state: TState) -&gt; TState:
    &#34;&#34;&#34;Applies a function to each element of the collection,
    threading an accumulator argument through the computation. If
    the input function is f and the elements are i0...iN then
    computes f (... (f s i0)...) iN

    Args:
        folder: A function that updates the state with each element
            from the sequence.
        state: The initial state.
    Returns:
        The state object after the folding function is applied to
        each element of the sequence.
    &#34;&#34;&#34;
    return functools.reduce(folder, self, state)  # type: ignore</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self) â€‘>Â ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first element of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self) -&gt; TSource:
    &#34;&#34;&#34;Returns the first element of the sequence.&#34;&#34;&#34;

    return head(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.length"><code class="name flex">
<span>def <span class="ident">length</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the length of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length(self) -&gt; int:
    &#34;&#34;&#34;Returns the length of the sequence.&#34;&#34;&#34;
    return length(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, mapper:Â Callable[[TSource],Â TResult]) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Map sequence.</p>
<p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>A function to transform items from the input sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, mapper: Callable[[TSource], TResult]) -&gt; Seq[TResult]:
    &#34;&#34;&#34;Map sequence.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection.

    Args:
        mapping: A function to transform items from the input sequence.

    Returns:
        The result sequence.
    &#34;&#34;&#34;

    return Seq(pipe(self, map(mapper)))</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.mapi"><code class="name flex">
<span>def <span class="ident">mapi</span></span>(<span>self, mapping:Â Callable[[int,Â TSource],Â TResult]) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Map list with index.</p>
<p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection. The integer index passed to the function indicates
the index (from 0) of element being transformed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>The function to transform elements and their
indices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The list of transformed elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mapi(self, mapping: Callable[[int, TSource], TResult]) -&gt; Seq[TResult]:
    &#34;&#34;&#34;Map list with index.

    Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection. The integer index passed to the function indicates
    the index (from 0) of element being transformed.

    Args:
        mapping: The function to transform elements and their
            indices.

    Returns:
        The list of transformed elements.
    &#34;&#34;&#34;
    return Seq(mapi(mapping)(self))</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, pattern:Â Optional[Any]Â =Â None) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, pattern: Optional[Any] = None) -&gt; Any:
    case: Case[Iterable[TSource]] = Case(self)
    return case(pattern) if pattern else case</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, *args:Â Any) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pipe sequence through the given functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, *args: Any) -&gt; Any:
    &#34;&#34;&#34;Pipe sequence through the given functions.&#34;&#34;&#34;
    return pipe(self, *args)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>self, scanner:Â Callable[[TState,Â TSource],Â TState], state:Â TState) â€‘>Â Iterable[~TState]</span>
</code></dt>
<dd>
<div class="desc"><p>Like fold, but computes on-demand and returns the sequence of
intermediary and final results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scanner</code></strong></dt>
<dd>A function that updates the state with each element
from the sequence.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>The initial state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resulting sequence of computed states.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan(self, scanner: Callable[[TState, TSource], TState], state: TState) -&gt; Iterable[TState]:
    &#34;&#34;&#34;Like fold, but computes on-demand and returns the sequence of
    intermediary and final results.

    Args:
        scanner: A function that updates the state with each element
            from the sequence.
        state: The initial state.

    Returns:
        The resulting sequence of computed states.
    &#34;&#34;&#34;
    return Seq(itertools.accumulate(self._value, scanner, initial=state))</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self, count:Â int) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that skips N elements of the underlying
sequence and then yields the remaining elements of the sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to skip.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(self, count: int) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns a sequence that skips N elements of the underlying
    sequence and then yields the remaining elements of the sequence.

    Args:
        count: The number of items to skip.
    &#34;&#34;&#34;
    return Seq(pipe(self, skip(count)))</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>self) â€‘>Â ~TSource</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of the elements in the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(self) -&gt; TSource:
    &#34;&#34;&#34;Returns the sum of the elements in the sequence.&#34;&#34;&#34;
    return sum(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.sum_by"><code class="name flex">
<span>def <span class="ident">sum_by</span></span>(<span>self, projection:Â Callable[[TSource],Â TResult]) â€‘>Â ~TResult</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of the results generated by applying the
function to each element of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_by(self, projection: Callable[[TSource], TResult]) -&gt; TResult:
    &#34;&#34;&#34;Returns the sum of the results generated by applying the
    function to each element of the sequence.&#34;&#34;&#34;
    return pipe(self, sum_by(projection))</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequence that skips 1 element of the underlying
sequence and then yields the remaining elements of the
sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns a sequence that skips 1 element of the underlying
    sequence and then yields the remaining elements of the
    sequence.&#34;&#34;&#34;
    return self.skip(1)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>self, count:Â int) â€‘>Â <a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first N elements of the sequence.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong></dt>
<dd>The number of items to take.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(self, count: int) -&gt; Seq[TSource]:
    &#34;&#34;&#34;Returns the first N elements of the sequence.

    Args:
        count: The number of items to take.
    &#34;&#34;&#34;
    return Seq(pipe(self, take(count)))</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>self) â€‘>Â 'FrozenList[TSource]'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(self) -&gt; &#34;FrozenList[TSource]&#34;:
    return to_list(self)</code></pre>
</details>
</dd>
<dt id="expression.collections.seq.Seq.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self, other:Â Iterable[TResult]) â€‘>Â Iterable[Tuple[~TSource,Â ~TResult]]</span>
</code></dt>
<dd>
<div class="desc"><p>Combines the two sequences into a list of pairs. The two
sequences need not have equal lengths: when one sequence is
exhausted any remaining elements in the other sequence are
ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>The second input sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self, other: Iterable[TResult]) -&gt; Iterable[Tuple[TSource, TResult]]:
    &#34;&#34;&#34;Combines the two sequences into a list of pairs. The two
    sequences need not have equal lengths: when one sequence is
    exhausted any remaining elements in the other sequence are
    ignored.

    Args:
        other: The second input sequence.

    Returns:
        The result sequence.
    &#34;&#34;&#34;
    return builtins.zip(self, other)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="expression.collections" href="index.html">expression.collections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="expression.collections.seq.empty" href="#expression.collections.seq.empty">empty</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="expression.collections.seq.append" href="#expression.collections.seq.append">append</a></code></li>
<li><code><a title="expression.collections.seq.choose" href="#expression.collections.seq.choose">choose</a></code></li>
<li><code><a title="expression.collections.seq.collect" href="#expression.collections.seq.collect">collect</a></code></li>
<li><code><a title="expression.collections.seq.concat" href="#expression.collections.seq.concat">concat</a></code></li>
<li><code><a title="expression.collections.seq.delay" href="#expression.collections.seq.delay">delay</a></code></li>
<li><code><a title="expression.collections.seq.filter" href="#expression.collections.seq.filter">filter</a></code></li>
<li><code><a title="expression.collections.seq.fold" href="#expression.collections.seq.fold">fold</a></code></li>
<li><code><a title="expression.collections.seq.fold_back" href="#expression.collections.seq.fold_back">fold_back</a></code></li>
<li><code><a title="expression.collections.seq.head" href="#expression.collections.seq.head">head</a></code></li>
<li><code><a title="expression.collections.seq.iter" href="#expression.collections.seq.iter">iter</a></code></li>
<li><code><a title="expression.collections.seq.map" href="#expression.collections.seq.map">map</a></code></li>
<li><code><a title="expression.collections.seq.mapi" href="#expression.collections.seq.mapi">mapi</a></code></li>
<li><code><a title="expression.collections.seq.max" href="#expression.collections.seq.max">max</a></code></li>
<li><code><a title="expression.collections.seq.min" href="#expression.collections.seq.min">min</a></code></li>
<li><code><a title="expression.collections.seq.min_by" href="#expression.collections.seq.min_by">min_by</a></code></li>
<li><code><a title="expression.collections.seq.of" href="#expression.collections.seq.of">of</a></code></li>
<li><code><a title="expression.collections.seq.of_iterable" href="#expression.collections.seq.of_iterable">of_iterable</a></code></li>
<li><code><a title="expression.collections.seq.of_list" href="#expression.collections.seq.of_list">of_list</a></code></li>
<li><code><a title="expression.collections.seq.range" href="#expression.collections.seq.range">range</a></code></li>
<li><code><a title="expression.collections.seq.scan" href="#expression.collections.seq.scan">scan</a></code></li>
<li><code><a title="expression.collections.seq.singleton" href="#expression.collections.seq.singleton">singleton</a></code></li>
<li><code><a title="expression.collections.seq.skip" href="#expression.collections.seq.skip">skip</a></code></li>
<li><code><a title="expression.collections.seq.sum" href="#expression.collections.seq.sum">sum</a></code></li>
<li><code><a title="expression.collections.seq.sum_by" href="#expression.collections.seq.sum_by">sum_by</a></code></li>
<li><code><a title="expression.collections.seq.tail" href="#expression.collections.seq.tail">tail</a></code></li>
<li><code><a title="expression.collections.seq.take" href="#expression.collections.seq.take">take</a></code></li>
<li><code><a title="expression.collections.seq.unfold" href="#expression.collections.seq.unfold">unfold</a></code></li>
<li><code><a title="expression.collections.seq.zip" href="#expression.collections.seq.zip">zip</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="expression.collections.seq.Seq" href="#expression.collections.seq.Seq">Seq</a></code></h4>
<ul class="two-column">
<li><code><a title="expression.collections.seq.Seq.append" href="#expression.collections.seq.Seq.append">append</a></code></li>
<li><code><a title="expression.collections.seq.Seq.choose" href="#expression.collections.seq.Seq.choose">choose</a></code></li>
<li><code><a title="expression.collections.seq.Seq.collect" href="#expression.collections.seq.Seq.collect">collect</a></code></li>
<li><code><a title="expression.collections.seq.Seq.delay" href="#expression.collections.seq.Seq.delay">delay</a></code></li>
<li><code><a title="expression.collections.seq.Seq.empty" href="#expression.collections.seq.Seq.empty">empty</a></code></li>
<li><code><a title="expression.collections.seq.Seq.filter" href="#expression.collections.seq.Seq.filter">filter</a></code></li>
<li><code><a title="expression.collections.seq.Seq.fold" href="#expression.collections.seq.Seq.fold">fold</a></code></li>
<li><code><a title="expression.collections.seq.Seq.head" href="#expression.collections.seq.Seq.head">head</a></code></li>
<li><code><a title="expression.collections.seq.Seq.length" href="#expression.collections.seq.Seq.length">length</a></code></li>
<li><code><a title="expression.collections.seq.Seq.map" href="#expression.collections.seq.Seq.map">map</a></code></li>
<li><code><a title="expression.collections.seq.Seq.mapi" href="#expression.collections.seq.Seq.mapi">mapi</a></code></li>
<li><code><a title="expression.collections.seq.Seq.match" href="#expression.collections.seq.Seq.match">match</a></code></li>
<li><code><a title="expression.collections.seq.Seq.of" href="#expression.collections.seq.Seq.of">of</a></code></li>
<li><code><a title="expression.collections.seq.Seq.of_iterable" href="#expression.collections.seq.Seq.of_iterable">of_iterable</a></code></li>
<li><code><a title="expression.collections.seq.Seq.pipe" href="#expression.collections.seq.Seq.pipe">pipe</a></code></li>
<li><code><a title="expression.collections.seq.Seq.range" href="#expression.collections.seq.Seq.range">range</a></code></li>
<li><code><a title="expression.collections.seq.Seq.scan" href="#expression.collections.seq.Seq.scan">scan</a></code></li>
<li><code><a title="expression.collections.seq.Seq.skip" href="#expression.collections.seq.Seq.skip">skip</a></code></li>
<li><code><a title="expression.collections.seq.Seq.sum" href="#expression.collections.seq.Seq.sum">sum</a></code></li>
<li><code><a title="expression.collections.seq.Seq.sum_by" href="#expression.collections.seq.Seq.sum_by">sum_by</a></code></li>
<li><code><a title="expression.collections.seq.Seq.tail" href="#expression.collections.seq.Seq.tail">tail</a></code></li>
<li><code><a title="expression.collections.seq.Seq.take" href="#expression.collections.seq.Seq.take">take</a></code></li>
<li><code><a title="expression.collections.seq.Seq.to_list" href="#expression.collections.seq.Seq.to_list">to_list</a></code></li>
<li><code><a title="expression.collections.seq.Seq.unfold" href="#expression.collections.seq.Seq.unfold">unfold</a></code></li>
<li><code><a title="expression.collections.seq.Seq.zip" href="#expression.collections.seq.Seq.zip">zip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.3.dev5+gbec6307</a>.</p>
</footer>
</body>
</html>