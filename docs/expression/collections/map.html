<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.3.dev5+gbec6307" />
<title>expression.collections.map API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>expression.collections.map</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Attribution to original authors of this code
# --------------------------------------------
# This code has been originally been ported from the Fable project which
# was originally ported from the FSharp project.
#
# Fable:
#   https://fable.io
# - Copyright (c) Alfonso Garcia-Caro and contributors.
# - MIT License
# - https://github.com/fable-compiler/Fable/blob/nagareyama/src/fable-library/Map.fs
#
# F#
# - https://github.com/dotnet/fsharp
# - Copyright (c) Microsoft Corporation. All Rights Reserved.
# - MIT License
# - https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/map.fs
from __future__ import annotations

from typing import Any, Callable, Iterable, Iterator, List, Mapping, Optional, Set, Tuple, TypeVar, cast, overload

from expression.core import Option, SupportsLessThan, pipe

from . import maptree, seq
from .frozenlist import FrozenList
from .maptree import MapTree

Key = TypeVar(&#34;Key&#34;, bound=SupportsLessThan)
Value = TypeVar(&#34;Value&#34;)
Result = TypeVar(&#34;Result&#34;)

T1 = TypeVar(&#34;T1&#34;)
T2 = TypeVar(&#34;T2&#34;)
T3 = TypeVar(&#34;T3&#34;)
T4 = TypeVar(&#34;T4&#34;)
T5 = TypeVar(&#34;T5&#34;)
T6 = TypeVar(&#34;T6&#34;)


class Map(Mapping[Key, Value]):
    &#34;&#34;&#34;The immutable map class.&#34;&#34;&#34;

    def __init__(self, __tree: Optional[MapTree[Key, Value]] = None) -&gt; None:
        self._tree: MapTree[Key, Value] = __tree if __tree else maptree.empty

    def add(self, key: Key, value: Value) -&gt; Map[Key, Value]:
        return Map(maptree.add(key, value, self._tree))

    @overload
    def pipe(self, __fn1: Callable[[Map[Key, Value]], Result]) -&gt; Result:
        ...

    @overload
    def pipe(self, __fn1: Callable[[Map[Key, Value]], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(self, __fn1: Callable[[Map[Key, Value]], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[Map[Key, Value]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[Map[Key, Value]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
    ) -&gt; T5:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[Map[Key, Value]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
        __fn6: Callable[[T5], T6],
    ) -&gt; T6:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe map through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    @staticmethod
    def create(ie: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        return create(ie)

    def contains_key(self, key: Key) -&gt; bool:
        return maptree.mem(key, self._tree)

    def change(self, key: Key, f: Callable[[Option[Value]], Option[Value]]) -&gt; Map[Key, Value]:
        return Map(maptree.change(key, f, self._tree))

    @staticmethod
    def empty() -&gt; Map[Key, Value]:
        return Map(maptree.empty)

    def is_empty(self) -&gt; bool:
        return maptree.is_empty(self._tree)

    def exists(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        return maptree.exists(predicate, self._tree)

    def filter(self, predicate: Callable[[Key, Value], bool]) -&gt; Map[Key, Value]:
        return Map(maptree.filter(predicate, self._tree))

    def for_all(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        &#34;&#34;&#34;Returns true if the given predicate returns true for all of
        the bindings in the map.

        Args:
            predicate: The function to test the input elements.

        Returns:
            True if the predicate evaluates to true for all of the
            bindings in the map.
        &#34;&#34;&#34;
        return maptree.forall(predicate, self._tree)

    def iterate(self, f: Callable[[Key, Value], None]) -&gt; None:
        return maptree.iter(f, self._tree)

    #     def MapRange (f:&#39;Value-&gt;&#39;Result) =
    #         return Map&lt;&#39;Key, &#39;Result&gt;(comparer, maptree.map f tree)

    def fold(self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Result:
        return maptree.fold(folder, state, self._tree)

    def fold_back(self, folder: Callable[[Tuple[Key, Value], Result], Result], state: Result) -&gt; Result:
        return maptree.fold_back(folder, self._tree, state)

    def map(self, mapping: Callable[[Key, Value], Result]) -&gt; Map[Key, Result]:
        &#34;&#34;&#34;Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection. The key passed to the function indicates the key of
        element being transformed.

        Args:
            mapping: The function to transform the key/value pairs

        Returns:
            The resulting map of keys and transformed values.
        &#34;&#34;&#34;
        return Map(maptree.map(mapping, self._tree))

    def partition(self, predicate: Callable[[Key, Value], bool]) -&gt; Tuple[Map[Key, Value], Map[Key, Value]]:
        r1, r2 = maptree.partition(predicate, self._tree)
        return Map(r1), Map(r2)

    # @overload
    # def get(self, key: Key) -&gt; Optional[Value]:
    #    ...

    # @overload
    # def get(self, key: Key, default: Value) -&gt; Value:
    #    ...

    # def get(self, key: Key, default: Union[Value, _T]) -&gt; Union[Value, _T]:
    #    for value in self.try_find(key):
    #        return value

    #   return default

    def items(self) -&gt; Set[Tuple[Key, Value]]:
        return set(maptree.to_seq(self._tree))

    def remove(self, key: Key) -&gt; Map[Key, Value]:
        return Map(maptree.remove(key, self._tree))

    def to_list(self) -&gt; FrozenList[Tuple[Key, Value]]:
        return maptree.to_list(self._tree)

    def to_seq(self) -&gt; Iterable[Tuple[Key, Value]]:
        &#34;&#34;&#34;Convert to sequence.

        Returns:
            Sequence of key, value tuples.
        &#34;&#34;&#34;
        return maptree.to_seq(self._tree)

    def try_get_value(self, key: Key, value: List[Value]):
        for v in maptree.try_find(key, self._tree).to_list():
            value.append(v)
            return True
        else:
            return False

    def try_find(self, key: Key) -&gt; Option[Value]:
        return maptree.try_find(key, self._tree)

    def try_pick(self, chooser: Callable[[Key, Value], Option[Result]]) -&gt; Option[Result]:
        return maptree.try_pick(chooser, self._tree)

    @staticmethod
    def of(**args: Value) -&gt; Map[str, Value]:
        return Map(maptree.of_seq(args.items()))

    @staticmethod
    def of_frozenlist(lst: FrozenList[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Generate map from list.

        Returns:
            The new map.
        &#34;&#34;&#34;
        return of_frozenlist((lst))

    @staticmethod
    def of_list(lst: List[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Generate map from list.

        Returns:
            The new map.
        &#34;&#34;&#34;
        return of_list((lst))

    @staticmethod
    def of_seq(sequence: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Generate map from sequence.

        Generates a new map from an iterable of key/value tuples. This
        is an alias for `Map.create`.

        Returns:
            The new map.
        &#34;&#34;&#34;
        return of_seq(sequence)

    def __hash__(self) -&gt; int:
        def combine_hash(x: int, y: int) -&gt; int:
            return (x &lt;&lt; 1) + y + 631

        res = 0
        for x, y in maptree.mk_iterator(self._tree):
            res = combine_hash(res, hash(x))
            res = combine_hash(res, hash(y))
        return res

    def __getitem__(self, k: Key) -&gt; Value:
        return maptree.find(k, self._tree)

    def __iter__(self) -&gt; Iterator[Key]:
        xs = maptree.mk_iterator(self._tree)
        return (k for (k, _) in xs)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the number of bindings in the map.&#34;&#34;&#34;
        return maptree.size(self._tree)

    def __contains__(self, o: Any) -&gt; bool:
        return self.contains_key(o)

    def __eq__(self, o: Any) -&gt; bool:
        if not isinstance(o, Map):
            return False

        other = cast(Map[Any, Any], o)
        iterator: Iterator[Tuple[Any, Any]] = iter(other.to_seq())

        for kv in self.to_seq():
            try:
                kv_other = next(iterator)
            except StopIteration:
                return False
            else:
                if kv != kv_other:
                    return False
        return True

    def __bool__(self) -&gt; bool:
        return not maptree.is_empty(self._tree)

    def __str__(self) -&gt; str:
        def to_str(item: Tuple[Key, Value]) -&gt; str:
            key, value = item
            if isinstance(key, str):
                return f&#39;(&#34;{key}&#34;, {value})&#39;
            return f&#34;({key}, {value})&#34;

        items = pipe(self.to_seq(), seq.map(to_str))
        return f&#34;map [{&#39;; &#39;.join(items)}]&#34;

    def __repr__(self) -&gt; str:
        return str(self)


def add(key: Key, value: Value) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Add key with value to map.

    Returns a new map with the binding added to the given map. If a
    binding with the given key already exists in the input map, the
    existing binding is replaced by the new binding in the result
    map.

    Args:
        key: The input key.
        value: The input value.

    Returns:
        A partially applied add function that takes the input map and returns
        the output map.
    &#34;&#34;&#34;

    def _add(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Add the partially applied key with value to map.

        Returns a new map with the binding added to the given map. If a
        binding with the given key already exists in the input map, the
        existing binding is replaced by the new binding in the result
        map.

        Args:
            table: The input table.

        Returns:
            The resulting map.
        &#34;&#34;&#34;
        return table.add(key, value)

    return _add


def change(key: Key, fn: Callable[[Option[Value]], Option[Value]]) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Returns a new map with the value stored under key changed
    according to f.

    Args:
        key: The input key.
        fn: The change function.
        table: The input table.

    Returns:
        The input key.
    &#34;&#34;&#34;

    def _change(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.change(key, fn)

    return _change


def contains_key(key: Key) -&gt; Callable[[Map[Key, Any]], bool]:
    def _contains_key(table: Map[Key, Any]) -&gt; bool:
        return table.contains_key(key)

    return _contains_key


def count(table: Map[Any, Any]) -&gt; int:
    &#34;&#34;&#34;Return the number of bindings in the map.&#34;&#34;&#34;
    return len(table)


def create(ie: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.of_seq(ie))


def find(key: Key) -&gt; Callable[[Map[Key, Value]], Value]:
    &#34;&#34;&#34;Lookup an element in the map, raising KeyNotFoundException if no
    binding exists in the map

    Args:
        key: The key to find.
        table: The map to find the key in.

    &#34;&#34;&#34;

    def _find(table: Map[Key, Value]) -&gt; Value:
        return table[key]

    return _find


def is_empty(table: Map[Any, Any]) -&gt; bool:
    &#34;&#34;&#34;Is the map empty?

    Args:
        table: The input map.

    Returns:
        True if the map is empty.
    &#34;&#34;&#34;
    return table.is_empty()


def iterate(action: Callable[[Key, Value], None]) -&gt; Callable[[Map[Key, Value]], None]:
    def _iterate(table: Map[Key, Value]) -&gt; None:
        return table.iterate(action)

    return _iterate


def try_pick(chooser: Callable[[Key, Value], Option[Result]]) -&gt; Callable[[Map[Key, Value]], Option[Result]]:
    &#34;&#34;&#34;Searches the map looking for the first element where the given
    function returns a Some value.

    Args:
        chooser: The function to generate options from the key/value
            pairs.
    Returns:
        Partially applied `try_pick` function that takes the input map
        and returns the first result.
    &#34;&#34;&#34;

    def _try_pick(table: Map[Key, Value]) -&gt; Option[Result]:
        return table.try_pick(chooser)

    return _try_pick


def pick(chooser: Callable[[Key, Value], Option[Result]]) -&gt; Callable[[Map[Key, Value]], Result]:
    def _try_pick(table: Map[Key, Value]) -&gt; Result:
        for res in table.try_pick(chooser):
            return res
        else:
            raise KeyError()

    return _try_pick


def exists(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], bool]:
    &#34;&#34;&#34;Returns true if the given predicate returns true for one of the bindings in the map.

    Args:
        predicate: The function to test the input elements.

    Returns:
        Partially applied function that takes a map table and returns
        true if the predicate returns true for one of the key/value
        pairs.
    &#34;&#34;&#34;

    def _exists(table: Map[Key, Value]) -&gt; bool:
        return table.exists(predicate)

    return _exists


def filter(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    def _filter(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.filter(predicate)

    return _filter


def for_all(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], bool]:
    def _for_all(table: Map[Key, Value]) -&gt; bool:
        return table.for_all(predicate)

    return _for_all


def map(mapping: Callable[[Key, Value], Result]) -&gt; Callable[[Map[Key, Value]], Map[Key, Result]]:
    def _map(table: Map[Key, Value]) -&gt; Map[Key, Result]:
        return table.map(mapping)

    return _map


def fold(folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Callable[[Map[Key, Value]], Result]:
    def _fold(table: Map[Key, Value]) -&gt; Result:
        return table.fold(folder, state)

    return _fold


def fold_back(
    folder: Callable[[Tuple[Key, Value], Result], Result], table: Map[Key, Value]
) -&gt; Callable[[Result], Result]:
    def _fold_back(state: Result) -&gt; Result:
        return table.fold_back(folder, state)

    return _fold_back


def partition(
    predicate: Callable[[Key, Value], bool]
) -&gt; Callable[[Map[Key, Value]], Tuple[Map[Key, Value], Map[Key, Value]]]:
    def _partition(table: Map[Key, Value]) -&gt; Tuple[Map[Key, Value], Map[Key, Value]]:
        return table.partition(predicate)

    return _partition


def remove(key: Key) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Removes an element from the domain of the map. No exception is
    raised if the element is not present.

    Args:
        key: The key to remove.
        table: The table to remove the key from.

    Returns:
        The resulting map.
    &#34;&#34;&#34;

    def _remove(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.remove(key)

    return _remove


# // [&lt;CompiledName(&#34;FindKey&#34;)&gt;]
# let findKey predicate (table : Map&lt;_, _&gt;) =
#     table |&gt; Seq.pick (fun kvp -&gt; let k = kvp.Key in if predicate k kvp.Value then Some k else None)

# // [&lt;CompiledName(&#34;TryFindKey&#34;)&gt;]
# let tryFindKey predicate (table : Map&lt;_, _&gt;) =
#     table |&gt; Seq.tryPick (fun kvp -&gt; let k = kvp.Key in if predicate k kvp.Value then Some k else None)


def of(**args: Value) -&gt; Map[str, Value]:
    &#34;&#34;&#34;Create map from arguments.&#34;&#34;&#34;
    return Map(maptree.of_seq(args.items()))


def of_frozenlist(elements: FrozenList[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.of_list(elements))


def of_list(elements: List[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.of_list(FrozenList(elements)))


def of_seq(elements: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.of_seq(elements))


def to_list(table: Map[Key, Value]) -&gt; FrozenList[Tuple[Key, Value]]:
    return table.to_list()


def to_seq(table: Map[Key, Value]) -&gt; Iterable[Tuple[Key, Value]]:
    return table.to_seq()


def try_find(key: Key) -&gt; Callable[[Map[Key, Value]], Option[Value]]:
    &#34;&#34;&#34;Lookup an element in the map, returning a `Some` value if the
    element is in the domain of the map and `Nothing` if not.

    Args:
        key: The input key.

    Returns:
        A partially applied `try_find` function that takes a map
        instance and returns the result.
    &#34;&#34;&#34;

    def _try_find(table: Map[Key, Value]) -&gt; Option[Value]:
        &#34;&#34;&#34;Lookup an element in the map, returning a `Some` value if the
        element is in the domain of the map and `Nothing` if not.

        Args:
            key: The input key.

        Returns:
            The found `Some` value or `Nothing`.
        &#34;&#34;&#34;
        return table.try_find(key)

    return _try_find


empty: Map[Any, Any] = Map.empty()

__all__ = [
    &#34;Map&#34;,
    &#34;add&#34;,
    &#34;change&#34;,
    &#34;create&#34;,
    &#34;contains_key&#34;,
    &#34;count&#34;,
    &#34;empty&#34;,
    &#34;exists&#34;,
    &#34;filter&#34;,
    &#34;find&#34;,
    &#34;fold&#34;,
    &#34;for_all&#34;,
    &#34;is_empty&#34;,
    &#34;iterate&#34;,
    &#34;map&#34;,
    &#34;of&#34;,
    &#34;of_frozenlist&#34;,
    &#34;of_list&#34;,
    &#34;of_seq&#34;,
    &#34;partition&#34;,
    &#34;pick&#34;,
    &#34;remove&#34;,
    &#34;to_list&#34;,
    &#34;to_seq&#34;,
    &#34;try_find&#34;,
    &#34;try_pick&#34;,
]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="expression.collections.map.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>key: Key, value: Value) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Add key with value to map.</p>
<p>Returns a new map with the binding added to the given map. If a
binding with the given key already exists in the input map, the
existing binding is replaced by the new binding in the result
map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The input key.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The input value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A partially applied add function that takes the input map and returns
the output map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(key: Key, value: Value) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Add key with value to map.

    Returns a new map with the binding added to the given map. If a
    binding with the given key already exists in the input map, the
    existing binding is replaced by the new binding in the result
    map.

    Args:
        key: The input key.
        value: The input value.

    Returns:
        A partially applied add function that takes the input map and returns
        the output map.
    &#34;&#34;&#34;

    def _add(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Add the partially applied key with value to map.

        Returns a new map with the binding added to the given map. If a
        binding with the given key already exists in the input map, the
        existing binding is replaced by the new binding in the result
        map.

        Args:
            table: The input table.

        Returns:
            The resulting map.
        &#34;&#34;&#34;
        return table.add(key, value)

    return _add</code></pre>
</details>
</dd>
<dt id="expression.collections.map.change"><code class="name flex">
<span>def <span class="ident">change</span></span>(<span>key: Key, fn: Callable[[Option[Value]], Option[Value]]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new map with the value stored under key changed
according to f.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The input key.</dd>
<dt><strong><code>fn</code></strong></dt>
<dd>The change function.</dd>
<dt><strong><code>table</code></strong></dt>
<dd>The input table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The input key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change(key: Key, fn: Callable[[Option[Value]], Option[Value]]) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Returns a new map with the value stored under key changed
    according to f.

    Args:
        key: The input key.
        fn: The change function.
        table: The input table.

    Returns:
        The input key.
    &#34;&#34;&#34;

    def _change(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.change(key, fn)

    return _change</code></pre>
</details>
</dd>
<dt id="expression.collections.map.contains_key"><code class="name flex">
<span>def <span class="ident">contains_key</span></span>(<span>key: Key) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, Any]], bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_key(key: Key) -&gt; Callable[[Map[Key, Any]], bool]:
    def _contains_key(table: Map[Key, Any]) -&gt; bool:
        return table.contains_key(key)

    return _contains_key</code></pre>
</details>
</dd>
<dt id="expression.collections.map.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>table: <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[Any, Any]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of bindings in the map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(table: Map[Any, Any]) -&gt; int:
    &#34;&#34;&#34;Return the number of bindings in the map.&#34;&#34;&#34;
    return len(table)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>ie: Iterable[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(ie: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.of_seq(ie))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>predicate: Callable[[Key, Value], bool]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the given predicate returns true for one of the bindings in the map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>The function to test the input elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied function that takes a map table and returns
true if the predicate returns true for one of the key/value
pairs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], bool]:
    &#34;&#34;&#34;Returns true if the given predicate returns true for one of the bindings in the map.

    Args:
        predicate: The function to test the input elements.

    Returns:
        Partially applied function that takes a map table and returns
        true if the predicate returns true for one of the key/value
        pairs.
    &#34;&#34;&#34;

    def _exists(table: Map[Key, Value]) -&gt; bool:
        return table.exists(predicate)

    return _exists</code></pre>
</details>
</dd>
<dt id="expression.collections.map.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>predicate: Callable[[Key, Value], bool]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    def _filter(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.filter(predicate)

    return _filter</code></pre>
</details>
</dd>
<dt id="expression.collections.map.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>key: Key) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], ~Value]</span>
</code></dt>
<dd>
<div class="desc"><p>Lookup an element in the map, raising KeyNotFoundException if no
binding exists in the map</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The key to find.</dd>
<dt><strong><code>table</code></strong></dt>
<dd>The map to find the key in.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(key: Key) -&gt; Callable[[Map[Key, Value]], Value]:
    &#34;&#34;&#34;Lookup an element in the map, raising KeyNotFoundException if no
    binding exists in the map

    Args:
        key: The key to find.
        table: The map to find the key in.

    &#34;&#34;&#34;

    def _find(table: Map[Key, Value]) -&gt; Value:
        return table[key]

    return _find</code></pre>
</details>
</dd>
<dt id="expression.collections.map.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], ~Result]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Callable[[Map[Key, Value]], Result]:
    def _fold(table: Map[Key, Value]) -&gt; Result:
        return table.fold(folder, state)

    return _fold</code></pre>
</details>
</dd>
<dt id="expression.collections.map.for_all"><code class="name flex">
<span>def <span class="ident">for_all</span></span>(<span>predicate: Callable[[Key, Value], bool]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def for_all(predicate: Callable[[Key, Value], bool]) -&gt; Callable[[Map[Key, Value]], bool]:
    def _for_all(table: Map[Key, Value]) -&gt; bool:
        return table.for_all(predicate)

    return _for_all</code></pre>
</details>
</dd>
<dt id="expression.collections.map.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>table: <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[Any, Any]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Is the map empty?</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>table</code></strong></dt>
<dd>The input map.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the map is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(table: Map[Any, Any]) -&gt; bool:
    &#34;&#34;&#34;Is the map empty?

    Args:
        table: The input map.

    Returns:
        True if the map is empty.
    &#34;&#34;&#34;
    return table.is_empty()</code></pre>
</details>
</dd>
<dt id="expression.collections.map.iterate"><code class="name flex">
<span>def <span class="ident">iterate</span></span>(<span>action: Callable[[Key, Value], None]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterate(action: Callable[[Key, Value], None]) -&gt; Callable[[Map[Key, Value]], None]:
    def _iterate(table: Map[Key, Value]) -&gt; None:
        return table.iterate(action)

    return _iterate</code></pre>
</details>
</dd>
<dt id="expression.collections.map.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>mapping: Callable[[Key, Value], Result]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Result]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(mapping: Callable[[Key, Value], Result]) -&gt; Callable[[Map[Key, Value]], Map[Key, Result]]:
    def _map(table: Map[Key, Value]) -&gt; Map[Key, Result]:
        return table.map(mapping)

    return _map</code></pre>
</details>
</dd>
<dt id="expression.collections.map.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>**args: Value) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create map from arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of(**args: Value) -&gt; Map[str, Value]:
    &#34;&#34;&#34;Create map from arguments.&#34;&#34;&#34;
    return Map(maptree.of_seq(args.items()))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.of_frozenlist"><code class="name flex">
<span>def <span class="ident">of_frozenlist</span></span>(<span>elements: FrozenList[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_frozenlist(elements: FrozenList[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.of_list(elements))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.of_list"><code class="name flex">
<span>def <span class="ident">of_list</span></span>(<span>elements: List[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_list(elements: List[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.of_list(FrozenList(elements)))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.of_seq"><code class="name flex">
<span>def <span class="ident">of_seq</span></span>(<span>elements: Iterable[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of_seq(elements: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.of_seq(elements))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>predicate: Callable[[Key, Value], bool]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], Tuple[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(
    predicate: Callable[[Key, Value], bool]
) -&gt; Callable[[Map[Key, Value]], Tuple[Map[Key, Value], Map[Key, Value]]]:
    def _partition(table: Map[Key, Value]) -&gt; Tuple[Map[Key, Value], Map[Key, Value]]:
        return table.partition(predicate)

    return _partition</code></pre>
</details>
</dd>
<dt id="expression.collections.map.pick"><code class="name flex">
<span>def <span class="ident">pick</span></span>(<span>chooser: Callable[[Key, Value], Option[Result]]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], ~Result]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pick(chooser: Callable[[Key, Value], Option[Result]]) -&gt; Callable[[Map[Key, Value]], Result]:
    def _try_pick(table: Map[Key, Value]) -&gt; Result:
        for res in table.try_pick(chooser):
            return res
        else:
            raise KeyError()

    return _try_pick</code></pre>
</details>
</dd>
<dt id="expression.collections.map.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>key: Key) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an element from the domain of the map. No exception is
raised if the element is not present.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The key to remove.</dd>
<dt><strong><code>table</code></strong></dt>
<dd>The table to remove the key from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resulting map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(key: Key) -&gt; Callable[[Map[Key, Value]], Map[Key, Value]]:
    &#34;&#34;&#34;Removes an element from the domain of the map. No exception is
    raised if the element is not present.

    Args:
        key: The key to remove.
        table: The table to remove the key from.

    Returns:
        The resulting map.
    &#34;&#34;&#34;

    def _remove(table: Map[Key, Value]) -&gt; Map[Key, Value]:
        return table.remove(key)

    return _remove</code></pre>
</details>
</dd>
<dt id="expression.collections.map.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>table: <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[Key, Value]) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(table: Map[Key, Value]) -&gt; FrozenList[Tuple[Key, Value]]:
    return table.to_list()</code></pre>
</details>
</dd>
<dt id="expression.collections.map.to_seq"><code class="name flex">
<span>def <span class="ident">to_seq</span></span>(<span>table: <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[Key, Value]) ‑> Iterable[Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_seq(table: Map[Key, Value]) -&gt; Iterable[Tuple[Key, Value]]:
    return table.to_seq()</code></pre>
</details>
</dd>
<dt id="expression.collections.map.try_find"><code class="name flex">
<span>def <span class="ident">try_find</span></span>(<span>key: Key) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Lookup an element in the map, returning a <code>Some</code> value if the
element is in the domain of the map and <code>Nothing</code> if not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The input key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A partially applied <code><a title="expression.collections.map.try_find" href="#expression.collections.map.try_find">try_find()</a></code> function that takes a map
instance and returns the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_find(key: Key) -&gt; Callable[[Map[Key, Value]], Option[Value]]:
    &#34;&#34;&#34;Lookup an element in the map, returning a `Some` value if the
    element is in the domain of the map and `Nothing` if not.

    Args:
        key: The input key.

    Returns:
        A partially applied `try_find` function that takes a map
        instance and returns the result.
    &#34;&#34;&#34;

    def _try_find(table: Map[Key, Value]) -&gt; Option[Value]:
        &#34;&#34;&#34;Lookup an element in the map, returning a `Some` value if the
        element is in the domain of the map and `Nothing` if not.

        Args:
            key: The input key.

        Returns:
            The found `Some` value or `Nothing`.
        &#34;&#34;&#34;
        return table.try_find(key)

    return _try_find</code></pre>
</details>
</dd>
<dt id="expression.collections.map.try_pick"><code class="name flex">
<span>def <span class="ident">try_pick</span></span>(<span>chooser: Callable[[Key, Value], Option[Result]]) ‑> Callable[[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]], <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a>[~Result]]</span>
</code></dt>
<dd>
<div class="desc"><p>Searches the map looking for the first element where the given
function returns a Some value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chooser</code></strong></dt>
<dd>The function to generate options from the key/value
pairs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Partially applied <code><a title="expression.collections.map.try_pick" href="#expression.collections.map.try_pick">try_pick()</a></code> function that takes the input map
and returns the first result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_pick(chooser: Callable[[Key, Value], Option[Result]]) -&gt; Callable[[Map[Key, Value]], Option[Result]]:
    &#34;&#34;&#34;Searches the map looking for the first element where the given
    function returns a Some value.

    Args:
        chooser: The function to generate options from the key/value
            pairs.
    Returns:
        Partially applied `try_pick` function that takes the input map
        and returns the first result.
    &#34;&#34;&#34;

    def _try_pick(table: Map[Key, Value]) -&gt; Option[Result]:
        return table.try_pick(chooser)

    return _try_pick</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="expression.collections.map.Map"><code class="flex name class">
<span>class <span class="ident">Map</span></span>
</code></dt>
<dd>
<div class="desc"><p>The immutable map class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Map(Mapping[Key, Value]):
    &#34;&#34;&#34;The immutable map class.&#34;&#34;&#34;

    def __init__(self, __tree: Optional[MapTree[Key, Value]] = None) -&gt; None:
        self._tree: MapTree[Key, Value] = __tree if __tree else maptree.empty

    def add(self, key: Key, value: Value) -&gt; Map[Key, Value]:
        return Map(maptree.add(key, value, self._tree))

    @overload
    def pipe(self, __fn1: Callable[[Map[Key, Value]], Result]) -&gt; Result:
        ...

    @overload
    def pipe(self, __fn1: Callable[[Map[Key, Value]], T1], __fn2: Callable[[T1], T2]) -&gt; T2:
        ...

    @overload
    def pipe(self, __fn1: Callable[[Map[Key, Value]], T1], __fn2: Callable[[T1], T2], __fn3: Callable[[T2], T3]) -&gt; T3:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[Map[Key, Value]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
    ) -&gt; T4:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[Map[Key, Value]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
    ) -&gt; T5:
        ...

    @overload
    def pipe(
        self,
        __fn1: Callable[[Map[Key, Value]], T1],
        __fn2: Callable[[T1], T2],
        __fn3: Callable[[T2], T3],
        __fn4: Callable[[T3], T4],
        __fn5: Callable[[T4], T5],
        __fn6: Callable[[T5], T6],
    ) -&gt; T6:
        ...

    def pipe(self, *args: Any) -&gt; Any:
        &#34;&#34;&#34;Pipe map through the given functions.&#34;&#34;&#34;
        return pipe(self, *args)

    @staticmethod
    def create(ie: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        return create(ie)

    def contains_key(self, key: Key) -&gt; bool:
        return maptree.mem(key, self._tree)

    def change(self, key: Key, f: Callable[[Option[Value]], Option[Value]]) -&gt; Map[Key, Value]:
        return Map(maptree.change(key, f, self._tree))

    @staticmethod
    def empty() -&gt; Map[Key, Value]:
        return Map(maptree.empty)

    def is_empty(self) -&gt; bool:
        return maptree.is_empty(self._tree)

    def exists(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        return maptree.exists(predicate, self._tree)

    def filter(self, predicate: Callable[[Key, Value], bool]) -&gt; Map[Key, Value]:
        return Map(maptree.filter(predicate, self._tree))

    def for_all(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
        &#34;&#34;&#34;Returns true if the given predicate returns true for all of
        the bindings in the map.

        Args:
            predicate: The function to test the input elements.

        Returns:
            True if the predicate evaluates to true for all of the
            bindings in the map.
        &#34;&#34;&#34;
        return maptree.forall(predicate, self._tree)

    def iterate(self, f: Callable[[Key, Value], None]) -&gt; None:
        return maptree.iter(f, self._tree)

    #     def MapRange (f:&#39;Value-&gt;&#39;Result) =
    #         return Map&lt;&#39;Key, &#39;Result&gt;(comparer, maptree.map f tree)

    def fold(self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Result:
        return maptree.fold(folder, state, self._tree)

    def fold_back(self, folder: Callable[[Tuple[Key, Value], Result], Result], state: Result) -&gt; Result:
        return maptree.fold_back(folder, self._tree, state)

    def map(self, mapping: Callable[[Key, Value], Result]) -&gt; Map[Key, Result]:
        &#34;&#34;&#34;Builds a new collection whose elements are the results of
        applying the given function to each of the elements of the
        collection. The key passed to the function indicates the key of
        element being transformed.

        Args:
            mapping: The function to transform the key/value pairs

        Returns:
            The resulting map of keys and transformed values.
        &#34;&#34;&#34;
        return Map(maptree.map(mapping, self._tree))

    def partition(self, predicate: Callable[[Key, Value], bool]) -&gt; Tuple[Map[Key, Value], Map[Key, Value]]:
        r1, r2 = maptree.partition(predicate, self._tree)
        return Map(r1), Map(r2)

    # @overload
    # def get(self, key: Key) -&gt; Optional[Value]:
    #    ...

    # @overload
    # def get(self, key: Key, default: Value) -&gt; Value:
    #    ...

    # def get(self, key: Key, default: Union[Value, _T]) -&gt; Union[Value, _T]:
    #    for value in self.try_find(key):
    #        return value

    #   return default

    def items(self) -&gt; Set[Tuple[Key, Value]]:
        return set(maptree.to_seq(self._tree))

    def remove(self, key: Key) -&gt; Map[Key, Value]:
        return Map(maptree.remove(key, self._tree))

    def to_list(self) -&gt; FrozenList[Tuple[Key, Value]]:
        return maptree.to_list(self._tree)

    def to_seq(self) -&gt; Iterable[Tuple[Key, Value]]:
        &#34;&#34;&#34;Convert to sequence.

        Returns:
            Sequence of key, value tuples.
        &#34;&#34;&#34;
        return maptree.to_seq(self._tree)

    def try_get_value(self, key: Key, value: List[Value]):
        for v in maptree.try_find(key, self._tree).to_list():
            value.append(v)
            return True
        else:
            return False

    def try_find(self, key: Key) -&gt; Option[Value]:
        return maptree.try_find(key, self._tree)

    def try_pick(self, chooser: Callable[[Key, Value], Option[Result]]) -&gt; Option[Result]:
        return maptree.try_pick(chooser, self._tree)

    @staticmethod
    def of(**args: Value) -&gt; Map[str, Value]:
        return Map(maptree.of_seq(args.items()))

    @staticmethod
    def of_frozenlist(lst: FrozenList[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Generate map from list.

        Returns:
            The new map.
        &#34;&#34;&#34;
        return of_frozenlist((lst))

    @staticmethod
    def of_list(lst: List[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Generate map from list.

        Returns:
            The new map.
        &#34;&#34;&#34;
        return of_list((lst))

    @staticmethod
    def of_seq(sequence: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
        &#34;&#34;&#34;Generate map from sequence.

        Generates a new map from an iterable of key/value tuples. This
        is an alias for `Map.create`.

        Returns:
            The new map.
        &#34;&#34;&#34;
        return of_seq(sequence)

    def __hash__(self) -&gt; int:
        def combine_hash(x: int, y: int) -&gt; int:
            return (x &lt;&lt; 1) + y + 631

        res = 0
        for x, y in maptree.mk_iterator(self._tree):
            res = combine_hash(res, hash(x))
            res = combine_hash(res, hash(y))
        return res

    def __getitem__(self, k: Key) -&gt; Value:
        return maptree.find(k, self._tree)

    def __iter__(self) -&gt; Iterator[Key]:
        xs = maptree.mk_iterator(self._tree)
        return (k for (k, _) in xs)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the number of bindings in the map.&#34;&#34;&#34;
        return maptree.size(self._tree)

    def __contains__(self, o: Any) -&gt; bool:
        return self.contains_key(o)

    def __eq__(self, o: Any) -&gt; bool:
        if not isinstance(o, Map):
            return False

        other = cast(Map[Any, Any], o)
        iterator: Iterator[Tuple[Any, Any]] = iter(other.to_seq())

        for kv in self.to_seq():
            try:
                kv_other = next(iterator)
            except StopIteration:
                return False
            else:
                if kv != kv_other:
                    return False
        return True

    def __bool__(self) -&gt; bool:
        return not maptree.is_empty(self._tree)

    def __str__(self) -&gt; str:
        def to_str(item: Tuple[Key, Value]) -&gt; str:
            key, value = item
            if isinstance(key, str):
                return f&#39;(&#34;{key}&#34;, {value})&#39;
            return f&#34;({key}, {value})&#34;

        items = pipe(self.to_seq(), seq.map(to_str))
        return f&#34;map [{&#39;; &#39;.join(items)}]&#34;

    def __repr__(self) -&gt; str:
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="expression.collections.map.Map.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>ie: Iterable[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create(ie: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    return create(ie)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty() -&gt; Map[Key, Value]:
    return Map(maptree.empty)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>**args: Value) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of(**args: Value) -&gt; Map[str, Value]:
    return Map(maptree.of_seq(args.items()))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.of_frozenlist"><code class="name flex">
<span>def <span class="ident">of_frozenlist</span></span>(<span>lst: FrozenList[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate map from list.</p>
<h2 id="returns">Returns</h2>
<p>The new map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of_frozenlist(lst: FrozenList[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    &#34;&#34;&#34;Generate map from list.

    Returns:
        The new map.
    &#34;&#34;&#34;
    return of_frozenlist((lst))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.of_list"><code class="name flex">
<span>def <span class="ident">of_list</span></span>(<span>lst: List[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate map from list.</p>
<h2 id="returns">Returns</h2>
<p>The new map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of_list(lst: List[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    &#34;&#34;&#34;Generate map from list.

    Returns:
        The new map.
    &#34;&#34;&#34;
    return of_list((lst))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.of_seq"><code class="name flex">
<span>def <span class="ident">of_seq</span></span>(<span>sequence: Iterable[Tuple[Key, Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate map from sequence.</p>
<p>Generates a new map from an iterable of key/value tuples. This
is an alias for <code><a title="expression.collections.map.Map.create" href="#expression.collections.map.Map.create">Map.create()</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>The new map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of_seq(sequence: Iterable[Tuple[Key, Value]]) -&gt; Map[Key, Value]:
    &#34;&#34;&#34;Generate map from sequence.

    Generates a new map from an iterable of key/value tuples. This
    is an alias for `Map.create`.

    Returns:
        The new map.
    &#34;&#34;&#34;
    return of_seq(sequence)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="expression.collections.map.Map.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, key: Key, value: Value) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, key: Key, value: Value) -&gt; Map[Key, Value]:
    return Map(maptree.add(key, value, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.change"><code class="name flex">
<span>def <span class="ident">change</span></span>(<span>self, key: Key, f: Callable[[Option[Value]], Option[Value]]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change(self, key: Key, f: Callable[[Option[Value]], Option[Value]]) -&gt; Map[Key, Value]:
    return Map(maptree.change(key, f, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.contains_key"><code class="name flex">
<span>def <span class="ident">contains_key</span></span>(<span>self, key: Key) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_key(self, key: Key) -&gt; bool:
    return maptree.mem(key, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, predicate: Callable[[Key, Value], bool]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
    return maptree.exists(predicate, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, predicate: Callable[[Key, Value], bool]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, predicate: Callable[[Key, Value], bool]) -&gt; Map[Key, Value]:
    return Map(maptree.filter(predicate, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) ‑> ~Result</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, folder: Callable[[Result, Tuple[Key, Value]], Result], state: Result) -&gt; Result:
    return maptree.fold(folder, state, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.fold_back"><code class="name flex">
<span>def <span class="ident">fold_back</span></span>(<span>self, folder: Callable[[Tuple[Key, Value], Result], Result], state: Result) ‑> ~Result</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold_back(self, folder: Callable[[Tuple[Key, Value], Result], Result], state: Result) -&gt; Result:
    return maptree.fold_back(folder, self._tree, state)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.for_all"><code class="name flex">
<span>def <span class="ident">for_all</span></span>(<span>self, predicate: Callable[[Key, Value], bool]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the given predicate returns true for all of
the bindings in the map.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>predicate</code></strong></dt>
<dd>The function to test the input elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the predicate evaluates to true for all of the
bindings in the map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def for_all(self, predicate: Callable[[Key, Value], bool]) -&gt; bool:
    &#34;&#34;&#34;Returns true if the given predicate returns true for all of
    the bindings in the map.

    Args:
        predicate: The function to test the input elements.

    Returns:
        True if the predicate evaluates to true for all of the
        bindings in the map.
    &#34;&#34;&#34;
    return maptree.forall(predicate, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self) -&gt; bool:
    return maptree.is_empty(self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self) ‑> Set[Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>D.items() -&gt; a set-like object providing a view on D's items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self) -&gt; Set[Tuple[Key, Value]]:
    return set(maptree.to_seq(self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.iterate"><code class="name flex">
<span>def <span class="ident">iterate</span></span>(<span>self, f: Callable[[Key, Value], None]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterate(self, f: Callable[[Key, Value], None]) -&gt; None:
    return maptree.iter(f, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, mapping: Callable[[Key, Value], Result]) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"><p>Builds a new collection whose elements are the results of
applying the given function to each of the elements of the
collection. The key passed to the function indicates the key of
element being transformed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>The function to transform the key/value pairs</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The resulting map of keys and transformed values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, mapping: Callable[[Key, Value], Result]) -&gt; Map[Key, Result]:
    &#34;&#34;&#34;Builds a new collection whose elements are the results of
    applying the given function to each of the elements of the
    collection. The key passed to the function indicates the key of
    element being transformed.

    Args:
        mapping: The function to transform the key/value pairs

    Returns:
        The resulting map of keys and transformed values.
    &#34;&#34;&#34;
    return Map(maptree.map(mapping, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>self, predicate: Callable[[Key, Value], bool]) ‑> Tuple[<a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value], <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a>[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(self, predicate: Callable[[Key, Value], bool]) -&gt; Tuple[Map[Key, Value], Map[Key, Value]]:
    r1, r2 = maptree.partition(predicate, self._tree)
    return Map(r1), Map(r2)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, *args: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pipe map through the given functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, *args: Any) -&gt; Any:
    &#34;&#34;&#34;Pipe map through the given functions.&#34;&#34;&#34;
    return pipe(self, *args)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, key: Key) ‑> <a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, key: Key) -&gt; Map[Key, Value]:
    return Map(maptree.remove(key, self._tree))</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>self) ‑> <a title="expression.collections.frozenlist.FrozenList" href="frozenlist.html#expression.collections.frozenlist.FrozenList">FrozenList</a>[typing.Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(self) -&gt; FrozenList[Tuple[Key, Value]]:
    return maptree.to_list(self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.to_seq"><code class="name flex">
<span>def <span class="ident">to_seq</span></span>(<span>self) ‑> Iterable[Tuple[~Key, ~Value]]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to sequence.</p>
<h2 id="returns">Returns</h2>
<p>Sequence of key, value tuples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_seq(self) -&gt; Iterable[Tuple[Key, Value]]:
    &#34;&#34;&#34;Convert to sequence.

    Returns:
        Sequence of key, value tuples.
    &#34;&#34;&#34;
    return maptree.to_seq(self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.try_find"><code class="name flex">
<span>def <span class="ident">try_find</span></span>(<span>self, key: Key) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_find(self, key: Key) -&gt; Option[Value]:
    return maptree.try_find(key, self._tree)</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.try_get_value"><code class="name flex">
<span>def <span class="ident">try_get_value</span></span>(<span>self, key: Key, value: List[Value])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_get_value(self, key: Key, value: List[Value]):
    for v in maptree.try_find(key, self._tree).to_list():
        value.append(v)
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="expression.collections.map.Map.try_pick"><code class="name flex">
<span>def <span class="ident">try_pick</span></span>(<span>self, chooser: Callable[[Key, Value], Option[Result]]) ‑> <a title="expression.core.option.Option" href="../core/option.html#expression.core.option.Option">Option</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_pick(self, chooser: Callable[[Key, Value], Option[Result]]) -&gt; Option[Result]:
    return maptree.try_pick(chooser, self._tree)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="expression.collections" href="index.html">expression.collections</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="expression.collections.map.add" href="#expression.collections.map.add">add</a></code></li>
<li><code><a title="expression.collections.map.change" href="#expression.collections.map.change">change</a></code></li>
<li><code><a title="expression.collections.map.contains_key" href="#expression.collections.map.contains_key">contains_key</a></code></li>
<li><code><a title="expression.collections.map.count" href="#expression.collections.map.count">count</a></code></li>
<li><code><a title="expression.collections.map.create" href="#expression.collections.map.create">create</a></code></li>
<li><code><a title="expression.collections.map.exists" href="#expression.collections.map.exists">exists</a></code></li>
<li><code><a title="expression.collections.map.filter" href="#expression.collections.map.filter">filter</a></code></li>
<li><code><a title="expression.collections.map.find" href="#expression.collections.map.find">find</a></code></li>
<li><code><a title="expression.collections.map.fold" href="#expression.collections.map.fold">fold</a></code></li>
<li><code><a title="expression.collections.map.for_all" href="#expression.collections.map.for_all">for_all</a></code></li>
<li><code><a title="expression.collections.map.is_empty" href="#expression.collections.map.is_empty">is_empty</a></code></li>
<li><code><a title="expression.collections.map.iterate" href="#expression.collections.map.iterate">iterate</a></code></li>
<li><code><a title="expression.collections.map.map" href="#expression.collections.map.map">map</a></code></li>
<li><code><a title="expression.collections.map.of" href="#expression.collections.map.of">of</a></code></li>
<li><code><a title="expression.collections.map.of_frozenlist" href="#expression.collections.map.of_frozenlist">of_frozenlist</a></code></li>
<li><code><a title="expression.collections.map.of_list" href="#expression.collections.map.of_list">of_list</a></code></li>
<li><code><a title="expression.collections.map.of_seq" href="#expression.collections.map.of_seq">of_seq</a></code></li>
<li><code><a title="expression.collections.map.partition" href="#expression.collections.map.partition">partition</a></code></li>
<li><code><a title="expression.collections.map.pick" href="#expression.collections.map.pick">pick</a></code></li>
<li><code><a title="expression.collections.map.remove" href="#expression.collections.map.remove">remove</a></code></li>
<li><code><a title="expression.collections.map.to_list" href="#expression.collections.map.to_list">to_list</a></code></li>
<li><code><a title="expression.collections.map.to_seq" href="#expression.collections.map.to_seq">to_seq</a></code></li>
<li><code><a title="expression.collections.map.try_find" href="#expression.collections.map.try_find">try_find</a></code></li>
<li><code><a title="expression.collections.map.try_pick" href="#expression.collections.map.try_pick">try_pick</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="expression.collections.map.Map" href="#expression.collections.map.Map">Map</a></code></h4>
<ul class="two-column">
<li><code><a title="expression.collections.map.Map.add" href="#expression.collections.map.Map.add">add</a></code></li>
<li><code><a title="expression.collections.map.Map.change" href="#expression.collections.map.Map.change">change</a></code></li>
<li><code><a title="expression.collections.map.Map.contains_key" href="#expression.collections.map.Map.contains_key">contains_key</a></code></li>
<li><code><a title="expression.collections.map.Map.create" href="#expression.collections.map.Map.create">create</a></code></li>
<li><code><a title="expression.collections.map.Map.empty" href="#expression.collections.map.Map.empty">empty</a></code></li>
<li><code><a title="expression.collections.map.Map.exists" href="#expression.collections.map.Map.exists">exists</a></code></li>
<li><code><a title="expression.collections.map.Map.filter" href="#expression.collections.map.Map.filter">filter</a></code></li>
<li><code><a title="expression.collections.map.Map.fold" href="#expression.collections.map.Map.fold">fold</a></code></li>
<li><code><a title="expression.collections.map.Map.fold_back" href="#expression.collections.map.Map.fold_back">fold_back</a></code></li>
<li><code><a title="expression.collections.map.Map.for_all" href="#expression.collections.map.Map.for_all">for_all</a></code></li>
<li><code><a title="expression.collections.map.Map.is_empty" href="#expression.collections.map.Map.is_empty">is_empty</a></code></li>
<li><code><a title="expression.collections.map.Map.items" href="#expression.collections.map.Map.items">items</a></code></li>
<li><code><a title="expression.collections.map.Map.iterate" href="#expression.collections.map.Map.iterate">iterate</a></code></li>
<li><code><a title="expression.collections.map.Map.map" href="#expression.collections.map.Map.map">map</a></code></li>
<li><code><a title="expression.collections.map.Map.of" href="#expression.collections.map.Map.of">of</a></code></li>
<li><code><a title="expression.collections.map.Map.of_frozenlist" href="#expression.collections.map.Map.of_frozenlist">of_frozenlist</a></code></li>
<li><code><a title="expression.collections.map.Map.of_list" href="#expression.collections.map.Map.of_list">of_list</a></code></li>
<li><code><a title="expression.collections.map.Map.of_seq" href="#expression.collections.map.Map.of_seq">of_seq</a></code></li>
<li><code><a title="expression.collections.map.Map.partition" href="#expression.collections.map.Map.partition">partition</a></code></li>
<li><code><a title="expression.collections.map.Map.pipe" href="#expression.collections.map.Map.pipe">pipe</a></code></li>
<li><code><a title="expression.collections.map.Map.remove" href="#expression.collections.map.Map.remove">remove</a></code></li>
<li><code><a title="expression.collections.map.Map.to_list" href="#expression.collections.map.Map.to_list">to_list</a></code></li>
<li><code><a title="expression.collections.map.Map.to_seq" href="#expression.collections.map.Map.to_seq">to_seq</a></code></li>
<li><code><a title="expression.collections.map.Map.try_find" href="#expression.collections.map.Map.try_find">try_find</a></code></li>
<li><code><a title="expression.collections.map.Map.try_get_value" href="#expression.collections.map.Map.try_get_value">try_get_value</a></code></li>
<li><code><a title="expression.collections.map.Map.try_pick" href="#expression.collections.map.Map.try_pick">try_pick</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.3.dev5+gbec6307</a>.</p>
</footer>
</body>
</html>